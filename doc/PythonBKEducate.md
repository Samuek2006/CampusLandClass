[TOC]



# Plan de Formaci√≥n

El programa cuenta con 60 horas de formaci√≥n distribuidas en actividades Asincr√≥nicas y trabajo aut√≥nomo para el desarrollo de habilidades que permitir√°n la aproximaci√≥n de los participantes en el mercado de la industria del desarrollo de software.

‚Ä¢    60 horas de sesiones Asincr√≥nicas orientadas por un experto espec√≠fico.



# Fundamentos de programaci√≥n

## Justificaci√≥n

En este ciclo se establecen los fundamentos que conforman los bloques de construcci√≥n, elementos y conceptos, de los programas inform√°ticos, los cuales son de gran importancia para desarrollar el tipo de pensamiento abstracto necesario para todo futuro ingeniero dentro de la sociedad de la informaci√≥n.

De igual manera se plantea como el espacio requerido para que el estudianteaprenda las diferentes estructuras de datos, operaciones, y mediciones de rendimiento presentes en todos los √°mbitos del desarrollo de software en la actualidad.



## Perfil de egreso:

El estudiante que haya culminado con √©xito este ciclo estar√° en la capacidad de:

‚Ä¢    Desarrollar un programa monousuario para resolver los requerimientos planteados por un tercero

‚Ä¢    Construir un programa trabajando de manera individual 

‚Ä¢    Construir un programa utilizando un lenguaje imperativo (Python) 

‚Ä¢    Construir un programa con una interfaz de consola o gr√°fica simple 

‚Ä¢    Construir un programa que maneje estructuras de datos lineales en memoria principal 

‚Ä¢    Construir un programa que maneje archivos de texto para almacenar informaci√≥n persistente (formato JSON / CSV) 

 

## Lenguaje de Programaci√≥n

El lenguaje seleccionado para desarrollar los contenidos del modulo  es Python. 

## Metodolog√≠a: 

A continuaci√≥n, se describe la metodolog√≠a a utilizar en el desarrollo del modulo: 

### **Sesiones Asincr√≥nica ** 

Durante el proceso de aprendizaje el estudiante contar√° con 60 horas de clase con un experto el cual explicar√° el contenido tem√°tico de cada unidad acad√©mica. 

Las sesiones se realizar√°n por medio de la plataforma Microsoft Teams, ser√°n grabadas y almacenadas en la plataforma LMS con el f√≠n de que el estudiante pueda acceder a ellas en cualquier momento y as√≠ realizar una retroalimentaci√≥n de lo trabajado durante cada una de las sesiones; las grabaciones estar√°n siempre disponibles a posterioridad. 

En cada sesi√≥n Asincr√≥nica    el estudiante deber√° registrar su asistencia en la plataforma LMS y as√≠ podr√° llevar a cabo un autocontrol de su aprendizaje. 

## Contenido Curricular programaci√≥n b√°sica con Python: 

A continuaci√≥n, se presenta el contenido curricular correspondiente al modulo con una duraci√≥n de 7 semanas 

### Programaci√≥n b√°sica con python

| Unidad de Aprendizaje             | Contenido                                                    | Duraci√≥n m√°xima (hras) | Tipo        |
| --------------------------------- | ------------------------------------------------------------ | ---------------------- | ----------- |
| 0. Algoritmia                     | ¬øQu√© es un Algoritmo?                                        |                        |             |
|                                   | ¬øQu√© es el Pseudoc√≥digo?                                     |                        |             |
|                                   | Elementos B√°sicos del Pseudoc√≥digo                           |                        |             |
|                                   |                                                              |                        |             |
| 1. Introducci√≥n a la Programaci√≥n |                                                              | 1                      | Asincr√≥nica |
|                                   | introducci√≥n al curso                                        |                        |             |
|                                   | ¬øQu√© es Python y porqu√© aprenderlo                           |                        |             |
|                                   | Instalaci√≥n de Python en Windows                             |                        |             |
|                                   | Introducci√≥n al modo interactivo de Python                   |                        |             |
|                                   | Palabras reservadas en Python                                |                        |             |
|                                   | Operadores matem√°ticos, l√≥gicos y relacionales               |                        |             |
|                                   | Entrada y salida  de usuario por modo interactivo            |                        |             |
|                                   | Test                                                         |                        |             |
| 2. Variables y tipos de datos     |                                                              | 1                      | Asincr√≥nica |
|                                   | Variables y constantes                                       |                        |             |
|                                   | Tipos de datos b√°sicos (Num√©ricos, cadenas y booleanos)      |                        |             |
|                                   | Conversi√≥n de tipos de datos o cast                          |                        |             |
|                                   | Test                                                         |                        |             |
| 3.Estructuras de control          |                                                              | 7                      | Asincr√≥nica |
|                                   | Condiciones- If y Else                                       |                        |             |
|                                   | Declaraci√≥n Match (Switch)                                   |                        |             |
|                                   | Bucle While                                                  |                        |             |
|                                   | Bucle For                                                    |                        |             |
|                                   | Continue, Break y Else en bucle                              |                        |             |
|                                   | Test                                                         |                        |             |
| 4.Control de errores              |                                                              | 4                      |             |
|                                   | Manejo de errores con Try, Except y Finally                  |                        |             |
|                                   | Test                                                         |                        |             |
| 5.Cadena de Caracteres            |                                                              | 5                      |             |
|                                   | M√©todos para Manipulaci√≥n B√°sica                             |                        |             |
|                                   | M√©todos para Validaci√≥n                                      |                        |             |
|                                   | M√©todos de Formateo                                          |                        |             |
|                                   | Test                                                         |                        |             |
| 6.Estructura de datos             |                                                              | 30                     |             |
|                                   | Listas                                                       | 11                     |             |
|                                   | Conceptos b√°sicos                                            |                        | Asincr√≥nica |
|                                   | Creaci√≥n de listas                                           |                        |             |
|                                   | Manipulaci√≥n de listas                                       |                        | Asincr√≥nica |
|                                   | A√±adiendo elementos a una lista (funci√≥n append o insert)    |                        |             |
|                                   | Eliminando items de una lista Python(funci√≥n pop, remove, delete) |                        |             |
|                                   | Iterando sobre una lista (bucles)                            |                        |             |
|                                   | Lista de listas                                              |                        | Asincr√≥nica |
|                                   | Ejercicio practico                                           |                        |             |
|                                   | **Diccionarios**                                             | 12                     |             |
|                                   | Conceptos b√°sicos                                            |                        |             |
|                                   | Creaci√≥n de diccionarios                                     |                        |             |
|                                   | Manipulaci√≥n de diccionarios                                 |                        |             |
|                                   | A√±adiendo elementos a un diccionario (funci√≥n update)        |                        |             |
|                                   | Eliminar llaves en un diccionario                            |                        |             |
|                                   | Eliminar elemento aleatoriamente                             |                        |             |
|                                   | Consultar los valores almacenados en un diccionario          |                        |             |
|                                   | Ejercicio                                                    |                        |             |
|                                   | **Tuplas**                                                   | 3                      |             |
|                                   | Conceptos b√°sicos                                            |                        |             |
|                                   | M√©todos                                                      |                        |             |
|                                   | **Sets**                                                     | 4                      |             |
|                                   | Conceptos b√°sicos                                            |                        |             |
|                                   | M√©todos de los sets                                          |                        |             |
|                                   | Test                                                         |                        |             |
| 7.Uso y manejo de funciones       | Conceptos b√°sicos                                            | 5                      |             |
|                                   | Estructura de una Funci√≥n Python                             |                        |             |
|                                   | Retornar m√∫ltiples valores desde una funci√≥n                 |                        |             |
|                                   | Funciones y no procedimientos                                |                        |             |
|                                   | Par√°metros especiales y argumentos de funciones              |                        |             |
|                                   | Par√°metros args y kargs                                      |                        |             |
| 8.Persistencia de datos           |                                                              | 7                      |             |

# üìîAlgoritmia

## ‚úÖ M√ìDULO 1: ¬øQu√© es un Algoritmo?

### üéØ Objetivo:

Comprender qu√© es un algoritmo, sus propiedades y su importancia en la resoluci√≥n de problemas.

### üß† Teor√≠a:

Un **algoritmo** es una secuencia **ordenada**, **finita** y **no ambigua** de pasos que resuelven un problema. Es la base de toda programaci√≥n.

### üß© Caracter√≠sticas:

- **Finito**: Tiene un inicio y un fin claros.
- **Ordenado**: Cada paso tiene una secuencia l√≥gica.
- **Preciso**: No deja lugar a dudas.
- **Efectivo**: Se puede llevar a cabo en la realidad

### üîç Ejemplo:

> Algoritmo para preparar un caf√©:
>
> 1. Calentar agua.
> 2. Servir caf√© en la taza.
> 3. Verter el agua caliente.
> 4. Revolver.
> 5. Listo.

## ‚úÖ M√ìDULO 2: Introducci√≥n al Pseudoc√≥digo

### üéØ Objetivo:

Aprender a expresar algoritmos mediante pseudoc√≥digo claro y estructurado.

### üß† Teor√≠a:

El **pseudoc√≥digo** permite representar un algoritmo sin necesidad de programar. Usa estructuras comunes como `Inicio`, `Fin`, `Leer`, `Escribir`, `Si`, `Mientras`, `Para`, etc.

No tiene una sintaxis estricta, pero **debe ser coherente y comprensible**.

### üîç Ejemplo b√°sico:

```
Inicio
    Escribir "Ingrese su nombre:"
    Leer nombre
    Escribir "Hola ", nombre
Fin
```

## ‚úÖ M√ìDULO 3: Variables y Operaciones (versi√≥n ampliada)

### üéØ Objetivo:

Comprender qu√© son las variables, c√≥mo declararlas correctamente, sus tipos y c√≥mo se utilizan en operaciones.

------

### üß† ¬øQu√© es una variable?

Una **variable** es un espacio de memoria donde se guarda un valor que puede cambiar durante la ejecuci√≥n del algoritmo. Cada variable tiene:

- Un **nombre** (identificador).
- Un **tipo de dato**.
- Un **valor** asignado (puede cambiar).

------

### üìå Reglas para declarar variables en pseudoc√≥digo

A continuaci√≥n se presentan las **reglas m√°s importantes** al declarar variables en pseudoc√≥digo:

| Regla                                                | Descripci√≥n                                               | Ejemplo                          |
| ---------------------------------------------------- | --------------------------------------------------------- | -------------------------------- |
| 1. **Debe declararse antes de usarse**               | Toda variable debe definirse al inicio del algoritmo.     | `Entero edad`                    |
| 2. **Debe tener un tipo de dato definido**           | Indica si almacenar√° texto, n√∫meros enteros, reales, etc. | `Real promedio`                  |
| 3. **El nombre debe ser claro y representativo**     | El nombre debe indicar qu√© almacena.                      | `Cadena nombreCliente`           |
| 4. **No puede comenzar con un n√∫mero**               | Los nombres v√°lidos inician con una letra.                | ‚úÖ `nota1` ‚ùå `1nota`              |
| 5. **No debe tener espacios ni s√≠mbolos especiales** | Usa guiones bajos o camelCase si es necesario.            | ‚úÖ `totalVentas` ‚ùå `total ventas` |
| 6. **No usar palabras reservadas**                   | Evita palabras como `Inicio`, `Fin`, `Si`, etc.           | ‚ùå `Para`, `Leer`                 |



------

### üîß Tipos de Datos comunes:

| Tipo     | Significado                    | Ejemplo de valor |
| -------- | ------------------------------ | ---------------- |
| Entero   | N√∫meros sin decimales          | 5, -3, 100       |
| Real     | N√∫meros con decimales          | 3.14, -1.5       |
| Cadena   | Texto entre comillas           | "Hola", "Juan"   |
| Booleano | Verdadero o falso (true/false) | Verdadero        |



------

### üß™ Ejemplo de declaraci√≥n de variables y uso:

```
Inicio
    Entero edad
    Real nota1, nota2, promedio
    Cadena nombre

    Escribir "Ingrese su nombre:"
    Leer nombre
    Escribir "Ingrese su edad:"
    Leer edad
    Escribir "Ingrese dos notas:"
    Leer nota1, nota2

    promedio ‚Üê (nota1 + nota2) / 2
    Escribir "Hola ", nombre, ". Tu promedio es: ", promedio
Fin
```

## üìò Secci√≥n de pr√°ctica guiada: Declaraci√≥n y uso de variables

### ‚úçÔ∏è **Actividad 1: Declaraci√≥n seg√∫n requisitos**

A continuaci√≥n se presenta una tabla con descripciones. Declara una variable adecuada para cada caso, siguiendo las reglas de nombrado, tipo de dato y claridad.

| Descripci√≥n                               | Nombre sugerido   | Tipo de dato | Declaraci√≥n en pseudoc√≥digo |
| ----------------------------------------- | ----------------- | ------------ | --------------------------- |
| Edad de una persona                       | edad              | Entero       | `Entero edad`               |
| Nombre del estudiante                     | nombreEstudiante  | Cadena       | `Cadena nombreEstudiante`   |
| Precio de un producto                     | precioProducto    | Real         | `Real precioProducto`       |
| Si un usuario ha iniciado sesi√≥n (S√≠/No)  | sesionActiva      | Booleano     | `Booleano sesionActiva`     |
| Total de una factura en pesos colombianos | totalFactura      | Real         | `Real totalFactura`         |
| Cantidad de productos en una compra       | cantidadProductos | Entero       | `Entero cantidadProductos`  |



> ‚úÖ **Tarea:** Completa la tabla con tus propios nombres, tipos y declaraciones para las siguientes situaciones:
>
> - Velocidad de un auto en km/h.
> - El t√≠tulo de un libro.
> - Resultado de una operaci√≥n matem√°tica.
> - Estado de aprobaci√≥n de un examen.

------

### ‚úçÔ∏è **Actividad 2: Escribe un algoritmo**

> Escribe un algoritmo en pseudoc√≥digo que declare:
>
> - El nombre de un cliente
> - La cantidad de productos
> - El precio de un solo producto
>    Luego calcule el total a pagar y lo muestre.

Espacio para respuesta:

```
Inicio
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
Fin
```

------

## üìò Secci√≥n de correcci√≥n de errores comunes

### üß© **Actividad 3: Encuentra y corrige los errores**

A continuaci√≥n se presentan fragmentos de pseudoc√≥digo con errores en la declaraci√≥n y uso de variables. Encuentra y corrige los errores:

#### ‚ùå C√≥digo con errores:

```
Inicio
    Real 1precio
    cadena nombre cliente
    entero TotalCompra

    Leer nombre cliente
    Leer 1precio
    TotalCompra ‚Üê 1precio * 2
    Escribir "El total es: ", totalcompra
Fin
```

#### ‚úÖ Espacio para c√≥digo corregido:

```
Inicio
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
    _____________________________________
Fin
```

## ‚úÖ M√ìDULO 4: Estructuras Condicionales

### üéØ Objetivo:

Aplicar decisiones l√≥gicas dentro del pseudoc√≥digo.

### üß† Teor√≠a:

Las estructuras **condicionales** permiten ejecutar instrucciones si se cumple una **condici√≥n**.

### üß± Sintaxis:

```
Si condici√≥n Entonces
    [acciones]
Sino
    [otras acciones]
FinSi
```

### üîç Ejemplo:

```
Inicio
    Leer edad
    Si edad >= 18 Entonces
        Escribir "Puede votar"
    Sino
        Escribir "No puede votar"
    FinSi
Fin
```

### ‚ùó Operadores relacionales:

- `=` igual
- `<>` distinto
- `>` mayor que
- `<` menor que
- `>=` mayor o igual
- `<=` menor o igual

## ‚úÖ M√ìDULO 5: Estructuras Repetitivas (Ciclos)

### üéØ Objetivo:

Usar ciclos para repetir bloques de c√≥digo.

### üß† Teor√≠a:

Los **ciclos** permiten ejecutar un conjunto de instrucciones **m√∫ltiples veces**, de forma controlada.

### üåÄ Tipos:

#### üîÅ Mientras (While):

```
Mientras condici√≥n Hacer
    [acciones]
FinMientras
```

Se usa cuando **no sabes cu√°ntas veces se repetir√°**.

#### üîÅ Para (For):

```
Para i ‚Üê 1 Hasta 5 Con Paso 1 Hacer
    Escribir i
FinPara
```

Se usa cuando **s√≠ sabes cu√°ntas veces repetir√°s**.

### üîç Ejemplo 1 (contar del 1 al 5):

```
Inicio
    Para i ‚Üê 1 Hasta 5 Con Paso 1 Hacer
        Escribir i
    FinPara
Fin
```

### üîç Ejemplo 2 (leer hasta n√∫mero negativo):

```
Inicio
    Entero num, suma ‚Üê 0
    Mientras num >= 0 Hacer
        Leer num
        suma ‚Üê suma + num
    FinMientras
    Escribir "Suma total: ", suma
Fin
```

## üìò M√ìDULO 6: Tipos de Lenguajes de Programaci√≥n

### üéØ Objetivo:

Comprender los distintos tipos de lenguajes de programaci√≥n, su clasificaci√≥n y usos, para reconocer cu√°l es m√°s adecuado seg√∫n el contexto de desarrollo.

------

### üß† ¬øQu√© es un lenguaje de programaci√≥n?

Es un sistema de notaci√≥n formal dise√±ado para escribir instrucciones que una **computadora puede interpretar y ejecutar**. Es la forma en que los humanos se comunican con las m√°quinas.

------

### üß© Clasificaci√≥n general

Los lenguajes de programaci√≥n se pueden clasificar seg√∫n **su nivel de abstracci√≥n**, **su paradigma** y **su prop√≥sito**.

------

### üìå A. Seg√∫n el nivel de abstracci√≥n

| Tipo                    | Descripci√≥n                                                  | Ejemplo      |
| ----------------------- | ------------------------------------------------------------ | ------------ |
| Lenguaje de bajo nivel  | Cercano al hardware, dif√≠cil para humanos, r√°pido y eficiente | Ensamblador  |
| Lenguaje de medio nivel | Mezcla instrucciones de hardware con abstracci√≥n (m√°s f√°cil que ensamblador) | C            |
| Lenguaje de alto nivel  | F√°cil de leer y escribir para humanos. Independiente del hardware | Python, Java |



------

### üìå B. Seg√∫n el paradigma de programaci√≥n

| Paradigma           | Descripci√≥n                                                  | Ejemplos               |
| ------------------- | ------------------------------------------------------------ | ---------------------- |
| Imperativo          | Indica **c√≥mo se hace** paso a paso                          | C, Pascal, Python      |
| Orientado a objetos | Basado en clases y objetos que representan entidades del mundo real | Java, C#, Python       |
| Funcional           | Usa funciones puras, sin efectos secundarios                 | Haskell, Elixir, Scala |
| L√≥gico              | Se basa en reglas y hechos para resolver problemas           | Prolog                 |
| Declarativo         | Indica **qu√© se quiere** sin detallar c√≥mo                   | SQL, HTML              |



------

### üìå C. Seg√∫n su prop√≥sito

| Tipo                              | Descripci√≥n                   | Ejemplos                                               |
| --------------------------------- | ----------------------------- | ------------------------------------------------------ |
| Lenguajes de prop√≥sito general    | Se pueden usar para casi todo | Python, Java, C#                                       |
| Lenguajes de prop√≥sito espec√≠fico | Usados para tareas concretas  | SQL (bases de datos), R (estad√≠stica), VHDL (hardware) |



------

### üîç Ejemplo comparativo:

| Lenguaje | Nivel | Paradigma           | Uso t√≠pico                     |
| -------- | ----- | ------------------- | ------------------------------ |
| Python   | Alto  | Multiparadigma      | Web, scripts, ciencia de datos |
| Java     | Alto  | Orientado a objetos | Aplicaciones empresariales     |
| C        | Medio | Imperativo          | Sistemas operativos, drivers   |
| SQL      | Alto  | Declarativo         | Consultas a bases de datos     |
| Prolog   | Alto  | L√≥gico              | Inteligencia artificial        |



# üìîIntroducci√≥n a la Programaci√≥n

## üìñ¬øQu√© es Python y porqu√© aprenderlo

Python es un lenguaje de programaci√≥n interpretado y orientado a objetos desarrollado por Guido van Rossum en la d√©cada de 1980. Es unido al sistema operativo Unix y se utiliza para crear aplicaciones, scripts, proyecciones y ediciones gr√°ficas.

**Caracter√≠sticas clave de Python:**

1. **Interpretaci√≥n**: Python es un lenguaje de programaci√≥n interpretado, lo que significa que no se compila antes de ejecutarse.
2. **Orientado a objetos**: Python utiliza conceptos orientados a objetos (OO) para crear programas m√°s estructurados y seguros.
3. **Simplicidad**: La sintaxis de Python es simple y f√°cil de entender, lo que la hace accesible a programadores de todos los niveles.
4. **Librer√≠as extensas**: Python tiene una gran cantidad de librer√≠as extensas que simplifican el desarrollo de aplicaciones y proyectos.

**Por qu√© estudiar Python?**

1. **Aplicaciones pr√°cticas**: Python es una de las lenguajes de programaci√≥n m√°s populares para la creaci√≥n de aplicaciones web, programaci√≥n de bases de datos, an√°lisis de datos, inteligencia artificial y m√°s.
2. **Desarrollo web**: Python es un lenguaje ideal para el desarrollo de aplicaciones web din√°micas, gracias a las bibliotecas como Django y Flask.
3. **Programaci√≥n de bases de datos**: Python es utilizado para la creaci√≥n de aplicaciones de programaci√≥n de bases de datos, como SQLAlchemy y PySQLAlchemy.
4. **An√°lisis de datos**: Python es una herramienta popular para el an√°lisis de datos, gracias a bibliotecas como Pandas, NumPy y Matplotlib.
5. **Ciencia de los datos**: Python se utiliza en la ciencia de los datos para la creaci√≥n de modelos estad√≠sticos, algoritmos de aprendizaje autom√°tico y m√°s.
6. **Desarrollo de aplicaciones m√≥viles**: Python es una opci√≥n popular para el desarrollo de aplicaciones m√≥viles, gracias a frameworks como Kivy y Buildozer.

**Beneficios del estudio de Python:**

1. **Aprendizajes pr√°cticos**: El estudio de Python te ense√±ar√° a programar de manera efectiva y a entender los conceptos fundamentales de la programaci√≥n.
2. **Diversidad de aplicaciones**: La experiencia con Python te permitir√° explorar diversas √°reas de inter√©s, desde la web hasta el an√°lisis de datos y m√°s.
3. **Flexibilidad**: El lenguaje de Python es muy vers√°til y se puede utilizar para una amplia variedad de proyectos.

En resumen, estudiar Python te permitir√° aprender a programar de manera efectiva, a crear aplicaciones pr√°cticas y a entender los conceptos fundamentales de la programaci√≥n.

## üìñIntroducci√≥n al modo interactivo de Python

El **modo interactivo de Python** es una de las maneras m√°s r√°pidas y sencillas de trabajar con el lenguaje. Es √∫til para aprender, probar fragmentos de c√≥digo o realizar c√°lculos r√°pidos. A continuaci√≥n, se presenta una introducci√≥n detallada:

------

### üìÉ**¬øQu√© es el modo interactivo?**

El modo interactivo es una interfaz en la que puedes escribir c√≥digo de Python l√≠nea por l√≠nea, recibir retroalimentaci√≥n inmediata y ver el resultado de cada instrucci√≥n. Funciona como una calculadora avanzada y permite explorar el lenguaje de manera pr√°ctica.

------

### üìÉ**C√≥mo acceder al modo interactivo**

1. **Desde la terminal o l√≠nea de comandos:**

   - Abre la terminal (en Linux o macOS) o el s√≠mbolo del sistema (en Windows).

   - Escribe `python` o `python3` y presiona Enter.

   - Ver√°s algo como esto:
   
     En windows
   
     ![](https://i.ibb.co/5k3FpK5/image.png)
   
     En Linux
   
     ![](https://i.ibb.co/DKSywrz/image.png)

2. **Desde entornos de desarrollo integrados (IDE):**
- Muchos IDEs como PyCharm, VSCode o IDLE tienen consolas interactivas integradas.

------

### üìÉ**Caracter√≠sticas principales**

- **Ejecuci√≥n inmediata:** Cada instrucci√≥n que ingresas se ejecuta al instante y muestra el resultado.

  ```less
  >>> 2 + 2
  4
  ```

- **Exploraci√≥n r√°pida:** Puedes probar funciones, m√©todos y estructuras de datos f√°cilmente.

  ```less
  >>> "Hola".upper()
  'HOLA'
  >>> len([1, 2, 3])
  3
  ```

- **Autocompletado y ayuda integrada:**

  - Utiliza 

    ```
    help()
    ```

     para obtener informaci√≥n sobre funciones, clases o m√≥dulos.

    ```
    >>> help(print)
    ```
    
  - Con teclas como `Tab`, puedes autocompletar nombres de m√©todos o variables (disponible en REPL mejorados como IPython).

------

### üìÉ**Ejemplos b√°sicos**

1. **Usar Python como calculadora:**

   ```
   >>> 5 * 8
   40
   >>> (10 + 5) / 2
   7.5
   ```

2. **Definir variables y funciones:**

   ```
   >>> x = 10
   >>> y = 20
   >>> x + y
   30
   >>> def suma(a, b):
   ...     return a + b
   ...
   >>> suma(3, 5)
   8
   ```

3. **Probar estructuras de control:**

   ```
   >>> for i in range(3):
   ...     print(i)
   ...
   0
   1
   2
   ```

4. **Importar m√≥dulos:**

   ```
   >>> import math
   >>> math.sqrt(16)
   4.0
   ```

------

### üìÉ**Ventajas del modo interactivo**

- Ideal para aprender y experimentar con Python.
- Facilita la depuraci√≥n r√°pida de c√≥digo.
- Proporciona retroalimentaci√≥n inmediata sobre el resultado de las instrucciones.

------

### üìÉ**Limitaciones del modo interactivo**

- No est√° dise√±ado para ejecutar programas largos o complejos.
- Cada vez que cierras la sesi√≥n, las variables y funciones definidas se pierden.
- Para proyectos m√°s grandes, es mejor usar archivos `.py` y ejecutarlos en el int√©rprete.

------

### üìÉ**Alternativas mejoradas**

- IPython:

   Ofrece una experiencia interactiva m√°s rica con caracter√≠sticas como historial avanzado, salida m√°s clara y soporte para gr√°ficos.

  ```
  pip install ipython
  ipython
  ```

------

‚Äã	Windows

![](https://i.ibb.co/9w33GkV/image.png)

‚Äã	Linux

![](https://i.ibb.co/PWjW894/image.png)

### üìÉ**Salir del modo interactivo**

- Escribe `exit()` o usa la combinaci√≥n de teclas `Ctrl+D` (Linux/macOS) o `Ctrl+Z` seguido de Enter (Windows).

## üìîPalabras reservadas en Python

Las palabras reservadas en Python son identificadores predefinidos que tienen un significado especial dentro del lenguaje y no pueden ser utilizados como nombres de variables, funciones o clases. Estas palabras forman parte de la sintaxis de Python y son fundamentales para estructurar programas.

------

### üìÉ**Lista de palabras reservadas en Python**

A continuaci√≥n, se muestra una lista de las palabras reservadas en Python (v√°lida para versiones 3.10 y posteriores):

```less
plaintextCopiarEditarFalse      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```

------

### üìÉ**Categor√≠as de las palabras reservadas**

1. **Valores l√≥gicos:**
   - `True`, `False`, `None`
2. **Control de flujo:**
   - `if`, `elif`, `else`, `while`, `for`, `break`, `continue`, `pass`
3. **Declaraci√≥n de funciones y clases:**
   - `def`, `return`, `lambda`, `class`
4. **Manejo de excepciones:**
   - `try`, `except`, `finally`, `raise`, `assert`
5. **Operadores l√≥gicos:**
   - `and`, `or`, `not`, `is`, `in`
6. **Manipulaci√≥n de alcance:**
   - `global`, `nonlocal`, `del`
7. **Manejo de contexto:**
   - `with`, `as`
8. **Programaci√≥n as√≠ncrona:**
   - `async`, `await`

------

### üìÉ**Caracter√≠sticas importantes**

1. **Prohibido usarlas como identificadores:** Intentar utilizar una palabra reservada como nombre de una variable o funci√≥n generar√° un error de sintaxis.

   ```less
   >>> def class():
   ...     pass
   SyntaxError: invalid syntax
   ```

2. **Sensibilidad a may√∫sculas y min√∫sculas:** Las palabras reservadas distinguen entre letras may√∫sculas y min√∫sculas. Por ejemplo, `True` es v√°lido, pero `true` no lo es.

3. **Significado espec√≠fico:** Cada palabra reservada tiene una funci√≥n clara dentro del lenguaje, como definir estructuras condicionales, bucles, excepciones, entre otras.

------

### üìÉ**Ejemplo de uso**

#### **üîñControl de flujo:**

```less
if True:
    print("Esto se ejecuta")
else:
    print("Esto no se ejecutar√°")
```

#### üîñ**Definici√≥n de funciones:**

```
def sumar(a, b):
    return a + b
```

#### üîñ**Bucles:**

```less
for i in range(3):
    print(i)
```

#### **üîñManejo de excepciones:**

```less
try:
    x = 10 / 0
except ZeroDivisionError:
    print("No se puede dividir entre cero")
```

### üìÉ**Consulta de palabras reservadas**

Puede obtener la lista de palabras reservadas en Python utilizando el m√≥dulo `keyword`:

```less
import keyword
print(keyword.kwlist)
```

![](https://i.ibb.co/WsRPFD4/image.png)

## üìîOperadores matem√°ticos, l√≥gicos y relacionales

### üìÉOperadores Matem√°ticos

Los operadores matem√°ticos permiten realizar c√°lculos b√°sicos y avanzados. A continuaci√≥n, se presentan los m√°s comunes:

| Operador | Descripci√≥n      | Ejemplo   | Resultado |
| -------- | ---------------- | --------- | --------- |
| `+`      | Suma             | `5 + 3`   | `8`       |
| `-`      | Resta            | `10 - 4`  | `6`       |
| `*`      | Multiplicaci√≥n   | `2 * 3`   | `6`       |
| `/`      | Divisi√≥n         | `10 / 4`  | `2.5`     |
| `//`     | Divisi√≥n entera  | `10 // 4` | `2`       |
| `%`      | M√≥dulo (residuo) | `10 % 3`  | `1`       |
| `**`     | Potenciaci√≥n     | `2 ** 3`  | `8`       |

------

### üìÉ**Operadores relacionales (de comparaci√≥n)**

Los operadores relacionales comparan valores y devuelven un valor booleano (`True` o `False`).

| Operador | Descripci√≥n       | Ejemplo  | Resultado |
| -------- | ----------------- | -------- | --------- |
| `==`     | Igual a           | `5 == 5` | `True`    |
| `!=`     | Diferente de      | `5 != 3` | `True`    |
| `>`      | Mayor que         | `10 > 5` | `True`    |
| `<`      | Menor que         | `3 < 8`  | `True`    |
| `>=`     | Mayor o igual que | `7 >= 7` | `True`    |
| `<=`     | Menor o igual que | `4 <= 6` | `True`    |

------

### üìÉ**Operadores l√≥gicos**

Los operadores l√≥gicos permiten combinar condiciones o valores booleanos.

| Operador | Descripci√≥n                              | Ejemplo          | Resultado |
| -------- | ---------------------------------------- | ---------------- | --------- |
| `and`    | Retorna `True` si ambos son `True`       | `True and False` | `False`   |
| `or`     | Retorna `True` si al menos uno es `True` | `True or False`  | `True`    |
| `not`    | Niega el valor booleano                  | `not True`       | `False`   |

------

### üìÉ**Ejemplos combinados**

#### **üîñUso de operadores matem√°ticos:**

```less
x = 10
y = 3

print(x + y)  # 13
print(x % y)  # 1
print(x ** y) # 1000
```

#### üîñ**Uso de operadores relacionales:**

```less
a = 5
b = 7

print(a > b)  # False
print(a <= b) # True
```

#### üîñ**Uso de operadores l√≥gicos:**

```less
x = 5
y = 10

print(x > 2 and y < 15) # True
print(x < 0 or y > 15)  # False
print(not(x == 5))      # False
```

## üìîEntrada y salida  de usuario por modo interactivo

En Python, la entrada y salida de usuario en modo interactivo permite interactuar con el programa, solicitando datos al usuario y mostrando resultados. Esto se logra principalmente con las funciones integradas `input()` para la entrada y `print()` para la salida.

------

### üìÉ**Entrada de usuario con `input()`**

La funci√≥n `input()` permite al usuario ingresar datos desde el teclado.

#### üìÉ**Sintaxis b√°sica:**

```python
variable = input("Mensaje al usuario: ")
```

- `input()` siempre devuelve el valor ingresado como una **cadena de texto** (tipo `str`).

#### üìÉ**Ejemplo de uso:**

```python
nombre = input("¬øCu√°l es tu nombre? ")
print("Hola,", nombre)
```

#### üìÉ**Convertir la entrada a otros tipos de datos:**

Si se necesita un valor num√©rico, es necesario convertir expl√≠citamente el valor ingresado:

```python
edad = int(input("¬øCu√°ntos a√±os tienes? "))
print("El pr√≥ximo a√±o tendr√°s", edad + 1, "a√±os.")
```

------

### üìñ**Salida de datos con `print()`**

La funci√≥n `print()` muestra informaci√≥n en la pantalla.

#### üìÉ**Sintaxis b√°sica:**

```python
print(valor1, valor2, ..., sep=' ', end='\n')
```

- **`sep`**: Define el separador entre valores (por defecto, un espacio `' '`).
- **`end`**: Define lo que se agrega al final de la l√≠nea (por defecto, un salto de l√≠nea `'\n'`).

#### üìÉ**Ejemplos de uso:**

```python
print("Hola, mundo")  # Salida: Hola, mundo
print("Python", "es", "genial", sep="-")  # Salida: Python-es-genial
print("Fin", end="!")  # Salida: Fin!
```

------

#### üìÉ**Ejemplo combinado: Calculadora interactiva**

Un programa que pide dos n√∫meros y muestra la suma:

```python
print("Bienvenido a la calculadora interactiva.")
num1 = float(input("Introduce el primer n√∫mero: "))
num2 = float(input("Introduce el segundo n√∫mero: "))
suma = num1 + num2
print("La suma de los n√∫meros es:", suma)
```

------

## **Uso avanzado de `print()` con formato**

La funci√≥n `print()` admite el uso de cadenas formateadas para una salida m√°s legible.

#### **Formato con `f-strings` (Python 3.6+):**

```python
nombre = "Ana"
edad = 25
print(f'Hola, {nombre}. Tienes {edad} a√±os.')
```

![](https://i.ibb.co/FXtVxt3/image.png)

#### **Formato con `str.format()`:**

```python
print("Hola, {}. Tienes {} a√±os.".format("Ana", 25))
```

![](https://i.ibb.co/YfFPgKq/image.png)

# üìîFunciones en Python

Una **funci√≥n** es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. Permite **organizar el c√≥digo**, **evitar repeticiones** y **mejorar la legibilidad**.

## üõ†Ô∏è Tipos de funciones en Python

### üîπ A. Funciones definidas por el lenguaje (built-in functions)

Estas vienen **predefinidas** en Python. Ejemplos:

```
print("Hola")         # Imprime en pantalla
len("Python")         # Devuelve la longitud de una cadena
sum([1, 2, 3])        # Suma los elementos de una lista
type(123)             # Devuelve el tipo del valor
```

üìö Referencia: [Built-in Functions ‚Äî Python Docs](https://docs.python.org/3/library/functions.html)

| Built-in Functions                                           |                                                              |                                                              |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **A**[`abs()`](https://docs.python.org/3/library/functions.html#abs)[`aiter()`](https://docs.python.org/3/library/functions.html#aiter)[`all()`](https://docs.python.org/3/library/functions.html#all)[`anext()`](https://docs.python.org/3/library/functions.html#anext)[`any()`](https://docs.python.org/3/library/functions.html#any)[`ascii()`](https://docs.python.org/3/library/functions.html#ascii) **B**[`bin()`](https://docs.python.org/3/library/functions.html#bin)[`bool()`](https://docs.python.org/3/library/functions.html#bool)[`breakpoint()`](https://docs.python.org/3/library/functions.html#breakpoint)[`bytearray()`](https://docs.python.org/3/library/functions.html#func-bytearray)[`bytes()`](https://docs.python.org/3/library/functions.html#func-bytes) **C**[`callable()`](https://docs.python.org/3/library/functions.html#callable)[`chr()`](https://docs.python.org/3/library/functions.html#chr)[`classmethod()`](https://docs.python.org/3/library/functions.html#classmethod)[`compile()`](https://docs.python.org/3/library/functions.html#compile)[`complex()`](https://docs.python.org/3/library/functions.html#complex) **D**[`delattr()`](https://docs.python.org/3/library/functions.html#delattr)[`dict()`](https://docs.python.org/3/library/functions.html#func-dict)[`dir()`](https://docs.python.org/3/library/functions.html#dir)[`divmod()`](https://docs.python.org/3/library/functions.html#divmod) | **E**[`enumerate()`](https://docs.python.org/3/library/functions.html#enumerate)[`eval()`](https://docs.python.org/3/library/functions.html#eval)[`exec()`](https://docs.python.org/3/library/functions.html#exec) **F**[`filter()`](https://docs.python.org/3/library/functions.html#filter)[`float()`](https://docs.python.org/3/library/functions.html#float)[`format()`](https://docs.python.org/3/library/functions.html#format)[`frozenset()`](https://docs.python.org/3/library/functions.html#func-frozenset) **G**[`getattr()`](https://docs.python.org/3/library/functions.html#getattr)[`globals()`](https://docs.python.org/3/library/functions.html#globals) **H**[`hasattr()`](https://docs.python.org/3/library/functions.html#hasattr)[`hash()`](https://docs.python.org/3/library/functions.html#hash)[`help()`](https://docs.python.org/3/library/functions.html#help)[`hex()`](https://docs.python.org/3/library/functions.html#hex) **I**[`id()`](https://docs.python.org/3/library/functions.html#id)[`input()`](https://docs.python.org/3/library/functions.html#input)[`int()`](https://docs.python.org/3/library/functions.html#int)[`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance)[`issubclass()`](https://docs.python.org/3/library/functions.html#issubclass)[`iter()`](https://docs.python.org/3/library/functions.html#iter) | **L**[`len()`](https://docs.python.org/3/library/functions.html#len)[`list()`](https://docs.python.org/3/library/functions.html#func-list)[`locals()`](https://docs.python.org/3/library/functions.html#locals) **M**[`map()`](https://docs.python.org/3/library/functions.html#map)[`max()`](https://docs.python.org/3/library/functions.html#max)[`memoryview()`](https://docs.python.org/3/library/functions.html#func-memoryview)[`min()`](https://docs.python.org/3/library/functions.html#min) **N**[`next()`](https://docs.python.org/3/library/functions.html#next) **O**[`object()`](https://docs.python.org/3/library/functions.html#object)[`oct()`](https://docs.python.org/3/library/functions.html#oct)[`open()`](https://docs.python.org/3/library/functions.html#open)[`ord()`](https://docs.python.org/3/library/functions.html#ord) **P**[`pow()`](https://docs.python.org/3/library/functions.html#pow)[`print()`](https://docs.python.org/3/library/functions.html#print)[`property()`](https://docs.python.org/3/library/functions.html#property) | **R**[`range()`](https://docs.python.org/3/library/functions.html#func-range)[`repr()`](https://docs.python.org/3/library/functions.html#repr)[`reversed()`](https://docs.python.org/3/library/functions.html#reversed)[`round()`](https://docs.python.org/3/library/functions.html#round) **S**[`set()`](https://docs.python.org/3/library/functions.html#func-set)[`setattr()`](https://docs.python.org/3/library/functions.html#setattr)[`slice()`](https://docs.python.org/3/library/functions.html#slice)[`sorted()`](https://docs.python.org/3/library/functions.html#sorted)[`staticmethod()`](https://docs.python.org/3/library/functions.html#staticmethod)[`str()`](https://docs.python.org/3/library/functions.html#func-str)[`sum()`](https://docs.python.org/3/library/functions.html#sum)[`super()`](https://docs.python.org/3/library/functions.html#super) **T**[`tuple()`](https://docs.python.org/3/library/functions.html#func-tuple)[`type()`](https://docs.python.org/3/library/functions.html#type) **V**[`vars()`](https://docs.python.org/3/library/functions.html#vars) **Z**[`zip()`](https://docs.python.org/3/library/functions.html#zip) **_**[`__import__()`](https://docs.python.org/3/library/functions.html#import__) |

------

### üî¢ 1. Funciones Num√©ricas

#### `abs()`: Valor absoluto

```
print(abs(-7))  # 7
```

#### `round()`: Redondeo

```
print(round(3.14159, 2))  # 3.14
```

#### `pow()`: Potencia (equivalente a `**`)

```
print(pow(2, 3))  # 8
```

#### `divmod()`: Divisi√≥n y m√≥dulo al mismo tiempo

```
print(divmod(10, 3))  # (3, 1) ‚Üí cociente y residuo
```

------

### üßÆ 2. Funciones para colecciones

#### `len()`: Longitud de una colecci√≥n

```
print(len([10, 20, 30]))  # 3
```

#### `sum()`: Suma elementos num√©ricos

```
print(sum([1, 2, 3, 4]))  # 10
```

#### `max()` y `min()`: Mayor y menor valor

```
print(max(10, 4, 8))  # 10
print(min(10, 4, 8))  # 4
```

------

### üîÑ 3. Conversi√≥n de tipos

#### `int()`, `float()`, `str()`, `bool()`

```
print(int("42"))     # 42
print(float("3.14")) # 3.14
print(str(100))      # "100"
print(bool(""))      # False
```

#### `list()`, `tuple()`, `set()`

```
print(list("hola"))   # ['h', 'o', 'l', 'a']
print(tuple([1, 2]))   # (1, 2)
print(set([1, 1, 2]))  # {1, 2}
```

------

### üß™ 4. Evaluaci√≥n y ejecuci√≥n

#### `type()`: Tipo de dato

```
print(type(5))  # <class 'int'>
```

#### `isinstance()`: Verifica si es de cierto tipo

```
print(isinstance(5, int))  # True
```

------

### üì¶ 5. Funciones de entrada/salida

#### `print()`: Imprimir en pantalla

```
print("Hola mundo")  # Hola mundo
```

#### `input()`: Leer del usuario

```
nombre = input("¬øTu nombre? ")
print("Hola,", nombre)
```

------

### üß† 6. Funciones l√≥gicas y de comparaci√≥n

#### `all()`: Todos los elementos son verdaderos

```
print(all([True, True, 1]))  # True
print(all([True, False]))    # False
```

#### `any()`: Al menos un elemento es verdadero

```
print(any([False, 0, "", 5]))  # True
```

------

### üß∞ 7. Funciones para programaci√≥n funcional

#### `map()`: Aplica una funci√≥n a una colecci√≥n

```
numeros = [1, 2, 3]
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)  # [1, 4, 9]
```

#### `filter()`: Filtra elementos con una condici√≥n

```
pares = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4]))
print(pares)  # [2, 4]
```

#### `zip()`: Une elementos por posici√≥n

```
nombres = ["Ana", "Luis"]
edades = [25, 30]
print(list(zip(nombres, edades)))  # [('Ana', 25), ('Luis', 30)]
```

### üîπ B. Funciones definidas por el usuario (user-defined functions)

Son creadas por el usuario usando la palabra clave `def`.

#### ‚úÖ Sintaxis b√°sica:

```python
def nombre_funcion(par√°metros):
    instrucciones
    return resultado
```

#### üß™ Ejemplo:

```python
def saludar(nombre):
    mensaje = f"Hola, {nombre}!"
    return mensaje

print(saludar("Johlver"))  # Hola, Johlver!
```

------

## üì¶ Componentes de una funci√≥n

| Componente | Descripci√≥n                                      |
| ---------- | ------------------------------------------------ |
| `def`      | Palabra clave para definir funciones             |
| Nombre     | Identificador de la funci√≥n                      |
| Par√°metros | Variables que recibe la funci√≥n                  |
| Cuerpo     | C√≥digo que se ejecuta cuando se llama la funci√≥n |
| `return`   | (Opcional) Devuelve un valor al terminar         |

## üßÆ Funciones sin par√°metros ni retorno

```python
def saludar():
    print("¬°Hola, mundo!")

saludar()  # ¬°Hola, mundo!
```

## üì§ Funciones con retorno (`return`)

```python
def sumar(a, b):
    return a + b

resultado = sumar(3, 5)
print(resultado)  # 8
```

### ¬øC√≥mo se puede especificar el tipo de dato que retorna una funci√≥n en Python?

En Python, desde la versi√≥n 3.5 en adelante, es posible **anotar el tipo de retorno** de una funci√≥n usando **type hints** (anotaciones de tipo). Esto permite indicar de manera expl√≠cita qu√© tipo de dato se espera que devuelva una funci√≥n, lo cual mejora la legibilidad del c√≥digo y ayuda a detectar errores antes de tiempo cuando se usan herramientas como `mypy`.

### üß† Sintaxis general

```
def nombre_funcion(par√°metros) -> TipoDeDatoEsperado:
    return resultado
```

El operador `->` se utiliza para declarar el tipo del valor que la funci√≥n devuelve.

------

### ‚úÖ Ejemplos pr√°cticos

#### 1. Funci√≥n que retorna un entero

```python
def multiplicar(a: int, b: int) -> int:
    return a * b

print (multiplicar(5,7))
```

Aqu√≠ se especifica que los par√°metros `a` y `b` son enteros y que la funci√≥n devolver√° un entero (`int`).

------

#### 2. Funci√≥n que retorna una cadena

```python
def saludar(nombre: str) -> str:
    return f"Hola, {nombre}"

print(f'{saludar(input('Ingrese su nombre : '))}')
```

------

#### 3. Funci√≥n que retorna una lista de enteros

```python
def crear_lista(n: int) -> list[int]:
    return list(range(n))

print(crear_lista(5))
```

> üí° En versiones anteriores a Python 3.9, se debe importar `List` desde el m√≥dulo `typing`:

```
from typing import List

def crear_lista(n: int) -> List[int]:
    return list(range(n))
```

------

#### 4. Funci√≥n que no retorna ning√∫n valor (`None`)

```python
def imprimir_mensaje(mensaje: str) -> None:
    print(mensaje)
imprimir_mensaje(input('Ingrese el mensaje a mostrar :'))
```

El tipo `None` indica que la funci√≥n no devuelve ning√∫n valor √∫til.

------

#### 5. Funci√≥n que puede devolver un valor o `None` (`Optional`)

```python
from typing import Optional

def buscar_elemento(lista: list[int], valor: int) -> Optional[int]:
    if valor in lista:
        return lista.index(valor)
    return None
valores = [1,4,5,7]
print(buscar_elemento(valores,10))
```

Aqu√≠ se aclara que la funci√≥n puede retornar un n√∫mero entero o `None`, dependiendo de si encuentra el valor.

------

#### 6. Funci√≥n que retorna m√∫ltiples valores en una tupla

```python
def operaciones(a: float, b: float) -> tuple[float, float]:
    return a + b, a * b

print(operaciones(3,2))
```

# üìî**Manejo de excepciones en la entrada**

Para evitar errores si el usuario ingresa datos no v√°lidos, se pueden usar excepciones:

```python
try:
    numero = int(input("Introduce un n√∫mero entero: "))
    print("El doble de tu n√∫mero es:", numero * 2)
except ValueError:
    print("Por favor, introduce un n√∫mero v√°lido.")
```

------

# üìîVariables y tipos de datos

### **üìñVariables y constantes**

#### üìÉ**Definici√≥n de variables**

Una **variable** es un espacio en la memoria que se utiliza para almacenar datos. En Python, las variables no necesitan ser declaradas con un tipo de dato expl√≠cito, ya que Python es un lenguaje de tipado din√°mico.

**Sintaxis b√°sica:**

```python
nombre_variable = valor
```

**Ejemplo:**

```python
nombre = "Juan"
edad = 25
es_estudiante = True
```

- Reglas para nombrar variables:
  - Deben comenzar con una letra o un guion bajo (`_`).
  - No pueden empezar con un n√∫mero.
  - No pueden contener espacios ni caracteres especiales.
  - No se deben usar palabras reservadas de Python.

#### üìÉ**Constantes**

Aunque Python no tiene una forma nativa de declarar constantes, se sigue una convenci√≥n: usar nombres en **may√∫sculas** para indicar que el valor no debe cambiar.

**Ejemplo:**

```python
PI = 3.14159
GRAVEDAD = 9.8
```

------

### üìñ**Tipos de datos b√°sicos**

Python ofrece tres tipos de datos b√°sicos m√°s comunes:

#### üìÉ**Num√©ricos**

- **Enteros (`int`):** N√∫meros sin decimales.

  ```python
  entero = 42
  ```

- **Flotantes (`float`):** N√∫meros con decimales.

  ```python
  flotante = 3.14
  ```

- **Complejos (`complex`):** N√∫meros con parte real e imaginaria.

  ```python
  complejo = 2 + 3j
  ```

#### üìÉ**Cadenas de texto (`str`)**

- Se utilizan para almacenar texto, definido entre comillas simples (`'`) o dobles (`"`).

  ```python
  saludo = "Hola, mundo"
  ```

- Soportan operaciones como concatenaci√≥n y repetici√≥n:

  ```python
  mensaje = "Hola" + " " + "Mundo"
  print(mensaje)  # Salida: Hola Mundo
  
  repetido = "Hola" * 3
  print(repetido)  # Salida: HolaHolaHola
  ```

#### üìÉ**Booleanos (`bool`)**

- Representan valores de verdad: 

  ```
  True
  ```

   o 

  ```
  False
  ```

  .

  ```python
  es_activo = True
  print(type(es_activo))  # Salida: <class 'bool'>
  ```

------

### üìñ**Conversi√≥n de tipos de datos o "casting"**

En Python, es posible convertir un tipo de dato en otro utilizando funciones de conversi√≥n.

#### üìÉ**Conversi√≥n impl√≠cita**

Python realiza conversiones autom√°ticas cuando no hay p√©rdida de informaci√≥n:

```python
num_entero = 5
num_flotante = 2.0
resultado = num_entero + num_flotante
print(resultado)  # Salida: 7.0
```

#### üìÉ**Conversi√≥n expl√≠cita**

Se usa cuando es necesario transformar un tipo de dato de forma manual.

**Funciones comunes:**

- `int()`: Convierte a entero.

  ```python
  entero = int(3.7)
  print(entero)  # Salida: 3
  ```

- `float()`: Convierte a flotante.

  ```python
  flotante = float(5)
  print(flotante)  # Salida: 5.0
  ```

- `str()`: Convierte a cadena.

  ```python
  texto = str(42)
  print(texto)  # Salida: "42"
  ```

- `bool()`: Convierte a booleano.

  ```python
  valor = bool(0)
  print(valor)  # Salida: False
  ```

#### üîñ**Ejemplo pr√°ctico de conversi√≥n de tipos:**

```python
edad = "25"  # Cadena
edad_entera = int(edad)  # Conversi√≥n a entero
print(edad_entera + 5)  # Salida: 30
```

------

#### üìú**Resumen final**

- Las **variables** almacenan datos y las **constantes** se usan para valores que no cambian.
- Los **tipos de datos b√°sicos** son num√©ricos, cadenas y booleanos.
- La **conversi√≥n de tipos** permite transformar datos entre distintos tipos, ya sea de forma impl√≠cita o expl√≠cita. Esto es √∫til para operaciones entre datos de diferentes tipos.

# üìîEstructuras de control

### üìñ**Condiciones: `if` y `else`**

Las estructuras condicionales permiten ejecutar diferentes bloques de c√≥digo dependiendo de si una condici√≥n se cumple o no.

#### **Sintaxis b√°sica:**

```python
if condici√≥n:
    # C√≥digo a ejecutar si la condici√≥n es verdadera
else:
    # C√≥digo a ejecutar si la condici√≥n es falsa
```

#### **Ejemplo b√°sico:**

```python
edad = 18
if edad >= 18:
    print("Eres mayor de edad")
else:
    print("Eres menor de edad")
```

#### **Uso de `elif`:**

Se utiliza cuando hay m√∫ltiples condiciones.

```python
nota = 85
if nota >= 90:
    print("Excelente")
elif nota >= 70:
    print("Aprobado")
else:
    print("Reprobado")
```

### üìñ**`match` (Switch)**

A partir de Python 3.10, la declaraci√≥n `match` permite realizar m√∫ltiples comparaciones de manera m√°s legible.

#### **Sintaxis b√°sica:**

```python
match variable:
    case valor1:
        # C√≥digo si variable == valor1
    case valor2:
        # C√≥digo si variable == valor2
    case _:
        # C√≥digo para cualquier otro caso
```

#### **Ejemplo:**

```python
opcion = 2
match opcion:
    case 1:
        print("Elegiste opci√≥n 1")
    case 2:
        print("Elegiste opci√≥n 2")
    case _:
        print("Opci√≥n no v√°lida")
```

### üìñ**Bucle `while`**

El bucle `while` ejecuta un bloque de c√≥digo mientras una condici√≥n sea verdadera.

#### **Sintaxis b√°sica**

```less
while condici√≥n:
    # C√≥digo a ejecutar mientras la condici√≥n sea verdadera
```

#### **Ejemplo b√°sico**

```less
contador = 1
while contador <= 5:
    print(contador)
    contador += 1
```

#### **Bucle infinito**

Un `while` sin una condici√≥n de salida puede generar un bucle infinito.

```less
while True:
    entrada = input("Escribe 'salir' para terminar: ")
    if entrada == "salir":
        break
```

### üìñ**Bucle `for`**

El bucle `for` se utiliza para iterar sobre elementos de una secuencia como listas, cadenas o rangos.

#### **Sintaxis b√°sica:**

```python
for elemento in secuencia:
    # C√≥digo a ejecutar por cada elemento
```

#### **Ejemplo b√°sico:**

```python
frutas = ["manzana", "pera", "uva"]
for fruta in frutas:
    print(fruta)
```

#### **Uso con `range()`:**

```python
for i in range(1, 6):
    print(i)
```

### üìñ**`continue`, `break` y `else` en bucles**

Estos comandos permiten controlar la ejecuci√≥n dentro de un bucle.

#### üìÉ**`break`:**

Finaliza el bucle de forma inmediata.

```python
for i in range(10):
    if i == 5:
        break
    print(i)
```

#### üìÉ**`continue`:**

Omite la iteraci√≥n actual y pasa a la siguiente.

```python
for i in range(5):
    if i == 2:
        continue
    print(i)
```

#### üìÉ**`else`:**

El bloque `else` en un bucle se ejecuta cuando el bucle termina de forma normal (sin un `break`).

```python
for i in range(5):
    print(i)
else:
    print("Bucle completado")
```

# üìîManejo de errores con Try, Except y Finally

El manejo de errores en Python se realiza mediante las sentencias `try`, `except`, y `finally`. Estas estructuras permiten gestionar situaciones en las que el c√≥digo puede generar errores, asegurando que el programa no se detenga inesperadamente y ofreciendo soluciones controladas a los problemas.

------

### üìñ**¬øQu√© es el manejo de errores?**

El manejo de errores consiste en anticipar posibles excepciones (errores) que puedan surgir durante la ejecuci√≥n de un programa y definir c√≥mo responder ante ellas. Esto mejora la robustez y estabilidad del c√≥digo.

------

### üìñ**La estructura b√°sica**

#### **Sintaxis:**

```python
try:
    # C√≥digo que puede generar un error
except ExcepcionEspecifica:
    # C√≥digo que se ejecuta si ocurre la excepci√≥n especificada
finally:
    # C√≥digo que se ejecuta siempre, ocurra o no una excepci√≥n (opcional)
```

------

### üìñ**Explicaci√≥n de las cl√°usulas**

#### **üìÉ`try`:**

Contiene el c√≥digo que se ejecuta normalmente, pero que puede generar una excepci√≥n.

#### **üìÉ `except`:**

Se ejecuta solo si ocurre una excepci√≥n en el bloque `try`. Puede manejar excepciones espec√≠ficas o generales.

**Ejemplo de manejo espec√≠fico:**

```python
try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("Error: No se puede dividir entre cero.")
```

**Ejemplo de manejo general:**

```python
try:
    resultado = int("texto")
except Exception as e:
    print(f"Error general: {e}")
```

#### **üìÉ `finally`:**

Se ejecuta siempre, independientemente de si ocurre o no una excepci√≥n. √ötil para realizar acciones de limpieza como cerrar archivos o liberar recursos.

**Ejemplo:**

```python
try:
    archivo = open("datos.txt", "r")
    contenido = archivo.read()
except FileNotFoundError:
    print("El archivo no existe.")
finally:
    print("Finalizando proceso...")
    if 'archivo' in locals() and not archivo.closed:
        archivo.close()
```

------

### üìñ**Capturar m√∫ltiples excepciones**

Un bloque `try` puede manejar diferentes tipos de excepciones usando varios bloques `except`:

```python
try:
    numero = int(input("Introduce un n√∫mero: "))
    resultado = 10 / numero
except ValueError:
    print("Debes introducir un n√∫mero v√°lido.")
except ZeroDivisionError:
    print("No se puede dividir entre cero.")
```

------

### üìñ**Usar `else` en el manejo de errores**

La cl√°usula `else` se ejecuta si no se produce ninguna excepci√≥n en el bloque `try`. Es √∫til para realizar acciones solo cuando no hubo errores.

**Ejemplo:**

```python
try:
    numero = int(input("Introduce un n√∫mero: "))
    resultado = 10 / numero
except (ValueError, ZeroDivisionError) as e:
    print(f"Error: {e}")
else:
    print("Operaci√≥n exitosa. Resultado:", resultado)
finally:
    print("Fin del programa.")
```

### üìñTipos de excepciones
| **Tipo de Error**        | **Descripci√≥n**                                                                 | **Ejemplo**                                                                                     |
|---------------------------|---------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **`SyntaxError`**         | Se genera cuando hay un error en la sintaxis del c√≥digo, lo que impide que sea interpretado. | ```python\nif True print("Hola")\n``` **Salida:** `SyntaxError: expected ':'`                 |
| **`IndentationError`**    | Se produce cuando hay un problema con la indentaci√≥n, como faltas o exceso de espacios.       | ```python\ndef funcion():\nprint("Hola")\n``` **Salida:** `IndentationError: expected an indented block` |
| **`NameError`**           | Ocurre cuando se intenta usar una variable o funci√≥n que no ha sido definida.               | ```python\nprint(x)\n``` **Salida:** `NameError: name 'x' is not defined`                     |
| **`TypeError`**           | Se lanza cuando se realiza una operaci√≥n no permitida entre tipos incompatibles.            | ```python\nresultado = "texto" + 5\n``` **Salida:** `TypeError: can only concatenate str (not "int") to str` |
| **`ValueError`**          | Ocurre cuando se proporciona un valor inapropiado para una operaci√≥n v√°lida.                | ```python\nnumero = int("texto")\n``` **Salida:** `ValueError: invalid literal for int() with base 10: 'texto'` |
| **`ZeroDivisionError`**   | Se genera cuando se intenta dividir un n√∫mero entre cero, lo cual no est√° permitido.         | ```python\nresultado = 10 / 0\n``` **Salida:** `ZeroDivisionError: division by zero`          |
| **`IndexError`**          | Se lanza cuando se intenta acceder a un √≠ndice que est√° fuera del rango de una lista o secuencia. | ```python\nlista = [1, 2, 3]\nprint(lista[5])\n``` **Salida:** `IndexError: list index out of range` |
| **`KeyError`**            | Se produce cuando se intenta acceder a una clave inexistente en un diccionario.             | ```python\ndiccionario = {"a": 1}\nprint(diccionario["b"])\n``` **Salida:** `KeyError: 'b'`   |
| **`AttributeError`**      | Ocurre cuando se intenta acceder a un atributo que no existe en un objeto.                  | ```python\ntexto = "Hola"\ntexto.append("!")\n``` **Salida:** `AttributeError: 'str' object has no attribute 'append'` |
| **`ModuleNotFoundError`** | Se genera cuando se intenta importar un m√≥dulo que no est√° disponible o no existe.          | ```python\nimport modulo_inexistente\n``` **Salida:** `ModuleNotFoundError: No module named 'modulo_inexistente'` |
| **`ImportError`**         | Ocurre cuando un m√≥dulo existe, pero hay problemas al importar algo espec√≠fico.             | ```python\nfrom math import raiz\n``` **Salida:** `ImportError: cannot import name 'raiz' from 'math'` |
| **`FileNotFoundError`**   | Se lanza cuando se intenta abrir un archivo que no existe en el sistema.                    | ```python\nwith open("archivo_inexistente.txt", "r") as archivo:\n    contenido = archivo.read()\n``` **Salida:** `FileNotFoundError: [Errno 2] No such file or directory: 'archivo_inexistente.txt'` |
| **`IOError`**             | Ocurre durante operaciones de entrada/salida que fallan, como leer o escribir un archivo.   | ```python\nwith open("/ruta_protegida/archivo.txt", "w") as archivo:\n    archivo.write("Texto")\n``` **Salida:** `IOError: [Errno 13] Permission denied: '/ruta_protegida/archivo.txt'` |
| **`OverflowError`**       | Se produce cuando un c√°lculo num√©rico excede el l√≠mite permitido.                          | ```python\nimport math\nresultado = math.exp(1000)\n``` **Salida:** `OverflowError: math range error` |
| **`RecursionError`**      | Se lanza cuando se excede el l√≠mite de recursi√≥n permitido en una funci√≥n recursiva.        | ```python\ndef recursiva():\n    return recursiva()\nrecursiva()\n``` **Salida:** `RecursionError: maximum recursion depth exceeded` |
| **`MemoryError`**         | Se genera cuando el sistema no tiene suficiente memoria para completar una operaci√≥n.       | ```python\nlista = [1] * (10**10)\n``` **Salida:** `MemoryError`                              |
| **`RuntimeError`**        | Error gen√©rico que ocurre en tiempo de ejecuci√≥n por condiciones inesperadas.               | ```python\nraise RuntimeError("Error inesperado")\n``` **Salida:** `RuntimeError: Error inesperado` |

# üìîCadena de Caracteres

## üìñ**M√©todos para Manipulaci√≥n B√°sica**

Python proporciona varios m√©todos integrados para manipular cadenas de caracteres. Estos permiten modificar, buscar, reemplazar o dividir cadenas f√°cilmente.

### üìÉ**Principales m√©todos:**

| **M√©todo**              | **Descripci√≥n**                                              | **Ejemplo**                             | **Resultado**       |
| ----------------------- | ------------------------------------------------------------ | --------------------------------------- | ------------------- |
| `len(cadena)`           | Devuelve la longitud de la cadena.                           | `len("Hola")`                           | `4`                 |
| `cadena.lower()`        | Convierte todos los caracteres de la cadena a min√∫sculas.    | `"Hola".lower()`                        | `"hola"`            |
| `cadena.upper()`        | Convierte todos los caracteres de la cadena a may√∫sculas.    | `"Hola".upper()`                        | `"HOLA"`            |
| `cadena.strip()`        | Elimina espacios en blanco al inicio y al final de la cadena. | `" Hola ".strip()`                      | `"Hola"`            |
| `cadena.replace(a, b)`  | Reemplaza todas las ocurrencias de `a` por `b` en la cadena. | `"Hola Mundo".replace("Hola", "Adi√≥s")` | `"Adi√≥s Mundo"`     |
| `cadena.split(sep)`     | Divide la cadena en una lista de palabras utilizando el separador `sep`. | `"Hola Mundo".split(" ")`               | `["Hola", "Mundo"]` |
| `cadena.join(iterable)` | Une los elementos de un iterable en una sola cadena usando `cadena` como separador. | `" ".join(["Hola", "Mundo"])`           | `"Hola Mundo"`      |

------

## üìñ**M√©todos para Validaci√≥n**

Estos m√©todos se utilizan para verificar si una cadena cumple con ciertas condiciones. Devuelven un valor booleano (`True` o `False`).

### üìÉ**Principales m√©todos:**

| **M√©todo**                   | **Descripci√≥n**                                              | **Ejemplo**                       | **Resultado** |
| ---------------------------- | ------------------------------------------------------------ | --------------------------------- | ------------- |
| `cadena.isalpha()`           | Retorna `True` si todos los caracteres son alfab√©ticos.      | `"Hola".isalpha()`                | `True`        |
| `cadena.isdigit()`           | Retorna `True` si todos los caracteres son d√≠gitos.          | `"1234".isdigit()`                | `True`        |
| `cadena.isalnum()`           | Retorna `True` si todos los caracteres son alfanum√©ricos (letras o n√∫meros). | `"Hola123".isalnum()`             | `True`        |
| `cadena.isspace()`           | Retorna `True` si todos los caracteres son espacios en blanco. | `" ".isspace()`                   | `True`        |
| `cadena.startswith(prefijo)` | Retorna `True` si la cadena comienza con el prefijo especificado. | `"Hola Mundo".startswith("Hola")` | `True`        |
| `cadena.endswith(sufijo)`    | Retorna `True` si la cadena termina con el sufijo especificado. | `"Hola Mundo".endswith("Mundo")`  | `True`        |

------

## üìñ**M√©todos de Formateo**

Estos m√©todos permiten ajustar o modificar el formato de una cadena.

### üìÉ**Principales m√©todos:**

| **M√©todo**                       | **Descripci√≥n**                                              | **Ejemplo**                          | **Resultado**   |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------ | --------------- |
| `cadena.center(ancho)`           | Centra la cadena dentro de un espacio de ancho especificado. | `"Hola".center(10)`                  | `" Hola "`      |
| `cadena.ljust(ancho)`            | Justifica la cadena a la izquierda con un ancho especificado. | `"Hola".ljust(10)`                   | `"Hola "`       |
| `cadena.rjust(ancho)`            | Justifica la cadena a la derecha con un ancho especificado.  | `"Hola".rjust(10)`                   | `" Hola"`       |
| `cadena.zfill(ancho)`            | Rellena la cadena con ceros a la izquierda hasta alcanzar el ancho especificado. | `"123".zfill(5)`                     | `"00123"`       |
| `cadena.format(*args, **kwargs)` | Reemplaza marcadores de posici√≥n `{}` en la cadena con los valores proporcionados. | `"Hola, {}".format("Mundo")`         | `"Hola, Mundo"` |
| `f"C√≥digo {variable}"`           | Cadenas formateadas (`f-strings`), permite insertar variables en la cadena. | `nombre = "Juan"; f"Hola, {nombre}"` | `"Hola, Juan"`  |

## ‚ùá**Taller Guiado: Trabajando con Cadenas de Caracteres en Python**

Este taller est√° dise√±ado para practicar el uso de cadenas de caracteres en Python. Cada ejercicio tiene instrucciones claras y una explicaci√≥n de c√≥mo resolverlo.

------

### **Objetivo del taller**

- Aprender a manipular, validar y formatear cadenas de caracteres.
- Usar los m√©todos b√°sicos de las cadenas para resolver problemas pr√°cticos.

------

### **Ejercicio 1: Contando caracteres**

#### **Instrucci√≥n:**

Escribe un programa que solicite al usuario una frase y muestre:

1. La cantidad total de caracteres en la frase.
2. La cantidad de espacios en la frase.

#### **Gu√≠a:**

1. Usa `len()` para contar el total de caracteres.
2. Usa el m√©todo `count()` para contar los espacios.

#### **C√≥digo base:**

```python
frase = input("Escribe una frase: ")
total_caracteres = len(frase)
espacios = frase.count(" ")

print(f"La frase tiene {total_caracteres} caracteres en total.")
print(f"La frase tiene {espacios} espacios.")
```

------

### **Ejercicio 2: Validando nombres**

#### **Instrucci√≥n:**

Crea un programa que solicite al usuario su nombre completo y verifique:

1. Que solo contenga letras.
2. Que comience con may√∫scula.

#### **Gu√≠a:**

1. Usa `isalpha()` para verificar que solo hay letras.
2. Usa `istitle()` para verificar que las palabras comiencen con may√∫scula.

#### **C√≥digo base:**

```python
nombre = input("Escribe tu nombre completo: ")

if nombre.replace(" ", "").isalpha():
    if nombre.istitle():
        print("El nombre es v√°lido.")
    else:
        print("El nombre debe comenzar con may√∫scula.")
else:
    print("El nombre solo debe contener letras.")
```

------

### **Ejercicio 3: Invirtiendo palabras**

#### **Instrucci√≥n:**

Escribe un programa que pida al usuario una palabra y muestre la palabra invertida.

#### **Gu√≠a:**

1. Usa el operador de slicing `[::-1]` para invertir la cadena.

#### **C√≥digo base:**

```python
palabra = input("Escribe una palabra: ")
invertida = palabra[::-1]
print(f"La palabra invertida es: {innvertida}")
```

------

### **Ejercicio 4: Cifrando texto**

#### **Instrucci√≥n:**

Crea un programa que solicite al usuario una frase y reemplace todas las vocales por un car√°cter especial (*).

#### **Gu√≠a:**

1. Usa `replace()` repetidamente para reemplazar las vocales.
2. Aseg√∫rate de manejar tanto may√∫sculas como min√∫sculas.

#### **C√≥digo base:**

```python
frase = input("Escribe una frase: ")

frase_cifrada = frase.replace("a", "*").replace("e", "*").replace("i", "*").replace("o", "*").replace("u", "*")
frase_cifrada = frase_cifrada.replace("A", "*").replace("E", "*").replace("I", "*").replace("O", "*").replace("U", "*")

print(f"La frase cifrada es: {frase_cifrada}")
```

------

### **Ejercicio 5: Contador de vocales**

#### **Instrucci√≥n:**

Escribe un programa que cuente cu√°ntas vocales hay en una frase ingresada por el usuario.

#### **Gu√≠a:**

1. Usa `count()` para contar las vocales individualmente.
2. Suma los resultados.

#### **C√≥digo base:**

```python
frase = input("Escribe una frase: ")

a = frase.count("a") + frase.count("A")
e = frase.count("e") + frase.count("E")
i = frase.count("i") + frase.count("I")
o = frase.count("o") + frase.count("O")
u = frase.count("u") + frase.count("U")

total_vocales = a + e + i + o + u

print(f"La frase tiene {total_vocales} vocales.")
```

------

### **Ejercicio 6: Formateando cadenas**

#### **Instrucci√≥n:**

Escribe un programa que tome un n√∫mero de tel√©fono ingresado por el usuario (10 d√≠gitos) y lo formatee como `(XXX) XXX-XXXX`.

#### **Gu√≠a:**

1. Usa slicing para dividir la cadena en partes.
2. Usa `f-strings` o concatenaci√≥n para formatear.

#### **C√≥digo base:**

```python
telefono = input("Escribe un n√∫mero de tel√©fono de 10 d√≠gitos: ")
if len(telefono) == 10 and telefono.isdigit():
    telefono_formateado = f"({telefono[:3]}) {telefono[3:6]}-{telefono[6:]}"
    print(f"El n√∫mero formateado es: {telefono_formateado}")
else:
    print("El n√∫mero debe tener exactamente 10 d√≠gitos.")
```

------

### **Ejercicio 7: Detectando pal√≠ndromos**

#### **Instrucci√≥n:**

Escribe un programa que determine si una palabra ingresada por el usuario es un pal√≠ndromo (se lee igual al derecho y al rev√©s).

#### **Gu√≠a:**

1. Usa slicing para invertir la palabra.
2. Compara la palabra original con la invertida.

#### **C√≥digo base:**

```python
palabra = input("Escribe una palabra: ").lower()
invertida = palabra[::-1]

if palabra == invertida:
    print("La palabra es un pal√≠ndromo.")
else:
    print("La palabra no es un pal√≠ndromo.")
```

# üìîEstructuras de datos

## üìñListas

Las listas en Python son estructuras de datos **ordenadas**, **mutables** y que pueden contener elementos de cualquier tipo (n√∫meros, cadenas, otros objetos, incluso otras listas). Son muy flexibles y se utilizan para almacenar colecciones de elementos.

#### üìÉ**Caracter√≠sticas clave:**

- Las listas est√°n delimitadas por corchetes (`[]`).
- Los elementos est√°n separados por comas.
- Pueden contener datos heterog√©neos.

**Ejemplo b√°sico:**

```python
pythonCopiarEditarmi_lista = [1, "Python", True, 3.14]
print(mi_lista)  # Salida: [1, 'Python', True, 3.14]
```

------

#### üìÉ**Creaci√≥n de listas**

Existen varias formas de crear listas en Python.

##### **üîñListas literales:**

Se crean directamente utilizando corchetes (`[]`).

```python
mi_lista = [1, 2, 3]
```

##### **üîñ Listas vac√≠as:**

```python
lista_vacia = []
```

##### **üîñUsando el constructor `list()`:**

```python
mi_lista = list((1, 2, 3))  # Se pasa una tupla como argumento
```

##### **üîñCon comprensi√≥n de listas:**

Una forma concisa de crear listas usando bucles.

```python
cuadrados = [x**2 for x in range(5)]  # Salida: [0, 1, 4, 9, 16]
```

------

### üìÉ**Manipulaci√≥n de listas**

Python proporciona muchos m√©todos y operadores para manipular listas.

#### **üîñ`append(x)`**

A√±ade un elemento al final de la lista.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.append(4)
print(mi_lista)  # Salida: [1, 2, 3, 4]
```

------

#### üîñ

Extiende la lista a√±adiendo todos los elementos de un iterable (como otra lista, una tupla o un string).

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.extend([4, 5, 6])
print(mi_lista)  # Salida: [1, 2, 3, 4, 5, 6]
```

------

#### **üîñ`insert(i, x)`**

Inserta un elemento en una posici√≥n espec√≠fica. `i` es el √≠ndice donde se insertar√° el elemento.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.insert(1, "Python")
print(mi_lista)  # Salida: [1, 'Python', 2, 3]
```

------

#### **üîñ `remove(x)`**

Elimina la primera aparici√≥n del valor `x` en la lista. Lanza un error si el valor no est√° presente.

**Ejemplo:**

```
mi_lista = [1, 2, 3, 2]
mi_lista.remove(2)
print(mi_lista)  # Salida: [1, 3, 2]
```

------

#### **üîñ `pop([i])`**

Elimina y devuelve el elemento en la posici√≥n `i`. Si no se especifica `i`, elimina y devuelve el √∫ltimo elemento.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
ultimo = mi_lista.pop()
print(ultimo)  # Salida: 3
print(mi_lista)  # Salida: [1, 2]
```

------

#### **üîñ`clear()`**

Elimina todos los elementos de la lista, dej√°ndola vac√≠a.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.clear()
print(mi_lista)  # Salida: []
```

------

#### **üîñ `index(x[, start[, end]])`**

Devuelve el √≠ndice de la primera aparici√≥n de `x` en la lista. Opcionalmente, se puede buscar dentro de un rango con `start` y `end`.

**Ejemplo:**

```
mi_lista = [10, 20, 30, 20]
indice = mi_lista.index(20)
print(indice)  # Salida: 1
```

**Con rango:**

```
indice = mi_lista.index(20, 2)
print(indice)  # Salida: 3
```

------

#### **üîñ`count(x)`**

Devuelve el n√∫mero de veces que `x` aparece en la lista.

**Ejemplo:**

```
mi_lista = [1, 2, 2, 3, 2]
cantidad = mi_lista.count(2)
print(cantidad)  # Salida: 3
```

------

#### **üîñ`sort(key=None, reverse=False)`**

Ordena los elementos de la lista de menor a mayor (por defecto). Se puede personalizar el orden con los par√°metros:

- **`key`:** Una funci√≥n que define el criterio de orden.
- **`reverse`:** Si es `True`, ordena de mayor a menor.

**Ejemplo b√°sico:**

```
mi_lista = [3, 1, 4, 2]
mi_lista.sort()
print(mi_lista)  # Salida: [1, 2, 3, 4]
```

**Orden descendente:**

```
mi_lista.sort(reverse=True)
print(mi_lista)  # Salida: [4, 3, 2, 1]
```

**Con clave personalizada:**

```
mi_lista = ["hola", "Python", "mundo"]
mi_lista.sort(key=len)
print(mi_lista)  # Salida: ['hola', 'mundo', 'Python']
```

------

#### **üîñ`reverse()`**

Invierte el orden de los elementos en la lista.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.reverse()
print(mi_lista)  # Salida: [3, 2, 1]
```

------

#### **üîñ `copy()`**

Devuelve una copia superficial de la lista. Los cambios en la copia no afectan a la lista original.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
copia = mi_lista.copy()
copia.append(4)
print(mi_lista)  # Salida: [1, 2, 3]
print(copia)     # Salida: [1, 2, 3, 4]
```

------

#### üìí**Resumen de M√©todos de Listas**

| **M√©todo**         | **Descripci√≥n**                                              |
| ------------------ | ------------------------------------------------------------ |
| `append(x)`        | A√±ade un elemento al final de la lista.                      |
| `extend(iterable)` | A√±ade todos los elementos de un iterable a la lista.         |
| `insert(i, x)`     | Inserta un elemento en la posici√≥n especificada.             |
| `remove(x)`        | Elimina la primera aparici√≥n del valor dado.                 |
| `pop([i])`         | Elimina y devuelve el elemento en la posici√≥n especificada (o el √∫ltimo). |
| `clear()`          | Elimina todos los elementos de la lista.                     |
| `index(x[, s, e])` | Devuelve el √≠ndice de la primera aparici√≥n de un valor.      |
| `count(x)`         | Cuenta cu√°ntas veces aparece un valor en la lista.           |
| `sort()`           | Ordena los elementos de la lista.                            |
| `reverse()`        | Invierte el orden de los elementos de la lista.              |
| `copy()`           | Devuelve una copia de la lista.                              |

```python
import random
import os
palabras = ['python', 'programacion', 'desarrollo', 'algoritmo', 'funcion']
def elegir_palabra():
    return random.choice(palabras)

def jugar_ahorcado():
    palabra = elegir_palabra()
    letras_adivinadas = []
    intentos = 6
    while intentos > 0:

        os.system('cls' if os.name == 'nt' else 'clear')
        print("\nPalabra\n", " ".join([letra if letra in letras_adivinadas else "_" for letra in palabra]))
        print("Letras adivinadas:", " ".join(letras_adivinadas))
        print(f"Intentos restantes: {intentos}")

        letra = input("Adivina una letra: ").lower()
        if letra in letras_adivinadas:
            print("Ya has adivinado esa letra.üòÇ")
            os.system('pause')
            continue
        letras_adivinadas.append(letra)
        if letra not in palabra:
            intentos -= 1
            print("Letra incorrecta.ü§¨")
            os.system('pause')
        else:
            print("¬°Bien hecho!")
        if all(letra in letras_adivinadas for letra in palabra):
            print(f"¬°Felicidades! Has adivinado la palabra: {palabra}")
            return
    print(f"Has perdidoü§Æ. La palabra era: {palabra}")
print("¬°Bienvenido al juego del ahorcado!")
jugar_ahorcado()  # Inicia el juego del ahorcado
```



## üìñ**Lista de listas**

Las listas pueden contener otras listas, lo que permite crear estructuras anidadas (matrices, tablas, etc.).

#### üìÉ**Acceso a listas anidadas:**

```python
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matriz[0])       # Salida: [1, 2, 3]
print(matriz[0][1])    # Salida: 2
```

#### **üìÉManipulaci√≥n de listas anidadas:**

```python
matriz[1].append(10)
print(matriz)  # Salida: [[1, 2, 3], [4, 5, 6, 10], [7, 8, 9]]
```

------

#### **Resumen**

Las listas en Python son una estructura de datos fundamental que permite almacenar y manipular colecciones de elementos de forma flexible. Aprender a usarlas de manera eficiente, incluyendo su creaci√≥n, manipulaci√≥n y uso en estructuras m√°s complejas como listas anidadas, es clave para desarrollar programas robustos.

## üìîDiccionarios

### üìñ**Conceptos b√°sicos**

Un diccionario en Python es una colecci√≥n de pares clave-valor, donde:

- Cada clave es √∫nica e inmutable (puede ser un n√∫mero, cadena o tupla).
- Cada valor est√° asociado con una clave y puede ser de cualquier tipo.

### üìñ**Caracter√≠sticas principales:**

- Los diccionarios son mutables (pueden modificarse despu√©s de ser creados).
- No admiten claves duplicadas, pero los valores s√≠ pueden repetirse.

#### **Ejemplo b√°sico:**

```python
mi_diccionario = {
    "nombre": "Juan",
    "edad": 30,
    "ciudad": "Bogot√°"
}
print(mi_diccionario)  # Salida: {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Bogot√°'}
```

### üìñ**Creaci√≥n de diccionarios**

Python ofrece varias formas de crear diccionarios.

#### **a) Usando llaves (`{}`):**

```python
diccionario = {"clave1": "valor1", "clave2": "valor2"}
```

#### **b) Usando el constructor `dict()`:**

```python
diccionario = dict(clave1="valor1", clave2="valor2")
```

#### **c) Diccionario vac√≠o:**

```python
diccionario = {}
```

#### **d) Usando `zip()`:**

Asocia elementos de dos listas para formar pares clave-valor.

```python
claves = ["nombre", "edad", "ciudad"]
valores = ["Ana", 25, "Medell√≠n"]
diccionario = dict(zip(claves, valores))
print(diccionario)  # Salida: {'nombre': 'Ana', 'edad': 25, 'ciudad': 'Medell√≠n'}
```

### üìñMetodos

#### **1. `dict.get(clave, valor_por_defecto=None)`**

Obtiene el valor asociado a una clave. Si la clave no existe, devuelve un valor por defecto (por defecto es `None`).

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.get("nombre"))  # Salida: Ana
print(diccionario.get("ciudad", "No especificado"))  # Salida: No especificado
```

------

#### **2. `dict.keys()`**

Devuelve una vista de todas las claves del diccionario.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.keys())  # Salida: dict_keys(['nombre', 'edad'])
```

------

#### **3. `dict.values()`**

Devuelve una vista de todos los valores del diccionario.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.values())  # Salida: dict_values(['Ana', 25])
```

------

#### **4. `dict.items()`**

Devuelve una vista de todos los pares clave-valor como tuplas.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.items())  # Salida: dict_items([('nombre', 'Ana'), ('edad', 25)])
```

------

#### **5. `dict.update(otro_diccionario)`**

Actualiza el diccionario con los pares clave-valor de otro diccionario o iterable.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana"}
nuevo_datos = {"edad": 25, "ciudad": "Bogot√°"}
diccionario.update(nuevo_datos)
print(diccionario)  # Salida: {'nombre': 'Ana', 'edad': 25, 'ciudad': 'Bogot√°'}
```

------

#### **6. `dict.pop(clave, valor_por_defecto)`**

Elimina la clave especificada y devuelve su valor. Si la clave no existe, devuelve el valor por defecto.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
edad = diccionario.pop("edad")
print(edad)  # Salida: 25
print(diccionario)  # Salida: {'nombre': 'Ana'}
```

------

#### **7. `dict.popitem()`**

Elimina y devuelve un par clave-valor aleatorio (en Python 3.7+ elimina el √∫ltimo).

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
par = diccionario.popitem()
print(par)  # Salida: ('edad', 25)
print(diccionario)  # Salida: {'nombre': 'Ana'}
```

------

#### **8. `dict.clear()`**

Elimina todos los elementos del diccionario, dej√°ndolo vac√≠o.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
diccionario.clear()
print(diccionario)  # Salida: {}
```

------

#### **9. `dict.copy()`**

Devuelve una copia superficial del diccionario.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
copia = diccionario.copy()
copia["ciudad"] = "Bogot√°"
print(diccionario)  # Salida: {'nombre': 'Ana', 'edad': 25}
print(copia)  # Salida: {'nombre': 'Ana', 'edad': 25, 'ciudad': 'Bogot√°'}
```

------

#### **10. `dict.setdefault(clave, valor_por_defecto)`**

Devuelve el valor de la clave si existe. Si no, agrega la clave con el valor por defecto y devuelve ese valor.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana"}
valor = diccionario.setdefault("ciudad", "Bogot√°")
print(valor)  # Salida: Bogot√°
print(diccionario)  # Salida: {'nombre': 'Ana', 'ciudad': 'Bogot√°'}
```

------

#### **11. `dict.fromkeys(iterable, valor_por_defecto=None)`**

Crea un diccionario con las claves del iterable y un valor por defecto para cada clave.

**Ejemplo:**

```python
claves = ["nombre", "edad", "ciudad"]
diccionario = dict.fromkeys(claves, "Desconocido")
print(diccionario)  # Salida: {'nombre': 'Desconocido', 'edad': 'Desconocido', 'ciudad': 'Desconocido'}
```

------

#### **12. Comparando diccionarios**

Se pueden usar operadores de comparaci√≥n para verificar igualdad.

**Ejemplo:**

```python
diccionario1 = {"nombre": "Ana", "edad": 25}
diccionario2 = {"edad": 25, "nombre": "Ana"}
print(diccionario1 == diccionario2)  # Salida: True
```

------

#### **Resumen de M√©todos**

| **M√©todo**                      | **Descripci√≥n**                                              |
| ------------------------------- | ------------------------------------------------------------ |
| `get(clave, valor_por_defecto)` | Devuelve el valor de una clave o un valor por defecto.       |
| `keys()`                        | Devuelve todas las claves del diccionario.                   |
| `values()`                      | Devuelve todos los valores del diccionario.                  |
| `items()`                       | Devuelve todos los pares clave-valor como tuplas.            |
| `update()`                      | Actualiza el diccionario con pares clave-valor de otro.      |
| `pop(clave, valor_por_defecto)` | Elimina y devuelve el valor asociado a una clave.            |
| `popitem()`                     | Elimina y devuelve un par clave-valor aleatorio.             |
| `clear()`                       | Elimina todos los elementos del diccionario.                 |
| `copy()`                        | Devuelve una copia superficial del diccionario.              |
| `setdefault(clave, valor)`      | Devuelve el valor de una clave, si no existe la agrega con el valor dado. |
| `fromkeys(iterable, valor)`     | Crea un diccionario con las claves del iterable y un valor com√∫n. |

# üìîPersistencia

### üìñ**Persistencia en Programaci√≥n**

La **persistencia en programaci√≥n** se refiere a la capacidad de un sistema o aplicaci√≥n para **almacenar y recuperar datos de manera duradera**, incluso despu√©s de que el programa haya terminado su ejecuci√≥n. Es un concepto fundamental en el desarrollo de software, especialmente en aplicaciones que requieren conservar informaci√≥n a lo largo del tiempo.

------

### üìñ**Tipos de Persistencia**

1. **Persistencia en Memoria (Vol√°til)**

   - Los datos se almacenan en la RAM mientras el programa est√° en ejecuci√≥n.
   - Ejemplo: Variables, arreglos, estructuras de datos temporales.
   - **Desventaja:** Los datos se pierden cuando el programa se cierra.

2. **Persistencia en Archivos (No Vol√°til)**

   - Guarda los datos en archivos en el sistema de almacenamiento.

   - Formatos comunes: `.txt`, `.csv`, `.json`, `.xml`, `.log`.

   - Ejemplo en Python:

     ```
     rwith open("datos.txt", "w") as archivo:
         archivo.write("Hola, esto es un archivo de texto")
     ```

3. **Persistencia en Bases de Datos**

   - Usa sistemas de bases de datos para almacenar grandes vol√∫menes de informaci√≥n.

   - Puede ser **relacional** (SQL) o **NoSQL** (MongoDB, Firebase).

   - Ejemplo en SQL (MySQL):

     ```
     CREATE TABLE usuarios (
         id INT PRIMARY KEY AUTO_INCREMENT,
         nombre VARCHAR(50),
         email VARCHAR(100)
     );
     ```

4. **Persistencia en la Nube**

   - Almacenamiento de datos en servidores remotos accesibles por Internet.
   - Ejemplos: Google Firebase, AWS S3, Microsoft Azure.

5. **Persistencia en Cach√©**

   - Se almacenan datos temporalmente en memoria para mejorar el rendimiento.
   - Ejemplo: Redis, Memcached.

------

### üìñ**Mecanismos de Persistencia**

‚úÖ **Bases de Datos Relacionales (SQL)**

- MySQL, PostgreSQL, Oracle, SQL Server.
- Usa **tablas y relaciones** para organizar los datos.

‚úÖ **Bases de Datos NoSQL**

- MongoDB, Firebase, CouchDB.
- Almacenan datos en formato **JSON o BSON**, sin estructuras fijas.

‚úÖ **Archivos Locales**

- Archivos JSON, XML, CSV, binarios.

‚úÖ **ORM (Object-Relational Mapping)**

- Herramientas como Hibernate (Java), SQLAlchemy (Python), TypeORM (JavaScript) permiten interactuar con bases de datos mediante objetos en lugar de SQL puro.

‚úÖ **Almacenamiento en la Nube**

- Firebase, AWS S3, Google Cloud Storage.

‚úÖ **Session Storage & Local Storage (Web)**

- Para persistencia en navegadores sin necesidad de base de datos.

- Ejemplo en JavaScript:

  ```
  localStorage.setItem("usuario", "Johlver");
  console.log(localStorage.getItem("usuario")); // "Johlver"
  ```

------

### üìñ**Ejemplo de Persistencia con JSON en JavaScript**

```
// Crear objeto
const usuario = { nombre: "Johlver", edad: 25 };

// Convertir a JSON y guardar en localStorage
localStorage.setItem("usuario", JSON.stringify(usuario));

// Recuperar datos
const datosRecuperados = JSON.parse(localStorage.getItem("usuario"));
console.log(datosRecuperados); // { nombre: "Johlver", edad: 25 }
```

------

### üìñ**Importancia de la Persistencia**

- Permite que los datos **se mantengan despu√©s de cerrar el programa**.
- Es clave en aplicaciones web, m√≥viles y sistemas empresariales.
- Mejora la escalabilidad y accesibilidad de la informaci√≥n.
- Facilita la **integraci√≥n con otras aplicaciones** y servicios.

### üìîArchivos en python

En Python, el manejo de archivos se realiza con la funci√≥n `open()`, que permite leer, escribir, modificar y cerrar archivos. A continuaci√≥n, te explicar√© los **m√©todos** y **par√°metros** m√°s usados en la manipulaci√≥n de archivos.

#### **üìå `open()` - Apertura de Archivos**

La funci√≥n `open()` se usa para abrir un archivo y devuelve un objeto de tipo archivo.

#### **üîπ Sintaxis:**

```
archivo = open("nombre_del_archivo", "modo", encoding="utf-8")
```

- `"nombre_del_archivo"`: Nombre del archivo con su ruta (ejemplo: `"datos.txt"`).
- `"modo"`: Indica la acci√≥n que se realizar√° sobre el archivo.
- `encoding="utf-8"`: (Opcional) Especifica la codificaci√≥n del archivo, recomendada para caracteres especiales.

------

#### **üìú Modos de Apertura de Archivos**

Los modos de apertura determinan qu√© operaci√≥n se realizar√° sobre el archivo:

| Modo   | Acci√≥n                                                       |
| ------ | ------------------------------------------------------------ |
| `"r"`  | Modo **lectura** (por defecto). Da error si el archivo no existe. |
| `"w"`  | Modo **escritura**, sobrescribe el archivo si ya existe. Si no existe, lo crea. |
| `"a"`  | Modo **agregar** (append). Agrega texto al final sin sobrescribir el contenido existente. |
| `"x"`  | Modo **creaci√≥n exclusiva**. Da error si el archivo ya existe. |
| `"r+"` | **Lectura y escritura**, sin borrar el contenido.            |
| `"w+"` | **Lectura y escritura**, pero sobrescribe el contenido.      |
| `"a+"` | **Lectura y escritura**, pero agrega datos al final.         |
| `"b"`  | Se usa junto con otros modos (`rb`, `wb`, `ab`) para archivos binarios. |

------

#### **üìå M√©todos para el Manejo de Archivos**

Una vez que se abre un archivo, se pueden usar los siguientes m√©todos:

#### **üìñ Lectura de Archivos**

##### üîπ `read()` - Lee todo el contenido del archivo

```python
with open("archivo.txt", "r", encoding="utf-8") as archivo:
    contenido = archivo.read()
    print(contenido)
```

üìå **Nota:** Si el archivo es muy grande, `read()` puede consumir mucha memoria.

##### üîπ `readline()` - Lee una sola l√≠nea

```python
with open("archivo.txt", "r", encoding="utf-8") as archivo:
    primera_linea = archivo.readline()
    print(primera_linea)
```

üìå **Nota:** Cada llamada a `readline()` lee la siguiente l√≠nea.

##### üîπ `readlines()` - Lee todas las l√≠neas y las almacena en una lista

```python
with open("archivo.txt", "r", encoding="utf-8") as archivo:
    lineas = archivo.readlines()
    print(lineas)  # ['Primera l√≠nea\n', 'Segunda l√≠nea\n']
```

üìå **Nota:** Cada l√≠nea incluye el salto de l√≠nea `\n`.

------

#### **‚úçÔ∏è Escritura en Archivos**

##### üîπ `write()` - Escribe una cadena en el archivo

```python
with open("archivo.txt", "w", encoding="utf-8") as archivo:
    archivo.write("Hola, este es un archivo de prueba.\n")
```

üìå **Nota:** Si el archivo existe, se sobrescribe.

##### üîπ `writelines()` - Escribe una lista de l√≠neas en el archivo

```python
lineas = ["L√≠nea 1\n", "L√≠nea 2\n", "L√≠nea 3\n"]

with open("archivo.txt", "w", encoding="utf-8") as archivo:
    archivo.writelines(lineas)
```

üìå **Nota:** `writelines()` **no** a√±ade autom√°ticamente `\n`, hay que incluirlo en cada l√≠nea.

------

#### **üìù Agregar Texto sin Sobrescribir**

Si quieres **a√±adir contenido al final** del archivo sin eliminar lo que ya existe, usa el modo `"a"`:

```python
with open("archivo.txt", "a", encoding="utf-8") as archivo:
    archivo.write("Esta l√≠nea se agrega al final.\n")
```

------

#### **üöÄ Lectura y Escritura al Mismo Tiempo**

Si deseas **leer y escribir** en el mismo archivo, usa `"r+"`, `"w+"` o `"a+"`:

```python
with open("archivo.txt", "r+", encoding="utf-8") as archivo:
    contenido = archivo.read()  # Leer contenido existente
    archivo.write("\nNueva l√≠nea agregada.")  # Escribir sin borrar
```

------

#### **üìå Cerrar un Archivo con `close()`**

Es importante cerrar los archivos despu√©s de usarlos para evitar p√©rdida de datos.

```python
archivo = open("archivo.txt", "r", encoding="utf-8")
contenido = archivo.read()
archivo.close()
```

‚úÖ **Recomendaci√≥n:** Usa `with open()` en lugar de `close()`, ya que Python cierra el archivo autom√°ticamente.

------

#### **üìÇ Ejemplo Completo: Gesti√≥n de Notas en un Archivo**

```python
def agregar_nota(nota):
    with open("notas.txt", "a", encoding="utf-8") as archivo:
        archivo.write(nota + "\n")

def mostrar_notas():
    with open("notas.txt", "r", encoding="utf-8") as archivo:
        print("üìÑ Notas Guardadas:")
        print(archivo.read())

# Agregar notas
agregar_nota("Estudiar Python")
agregar_nota("Practicar archivos en Python")

# Mostrar notas almacenadas
mostrar_notas()
```

------

#### **üîπ Resumen**

| M√©todo         | Descripci√≥n                                            |
| -------------- | ------------------------------------------------------ |
| `open()`       | Abre un archivo para lectura, escritura o ambos.       |
| `read()`       | Lee todo el contenido del archivo.                     |
| `readline()`   | Lee una l√≠nea del archivo.                             |
| `readlines()`  | Lee todas las l√≠neas y las guarda en una lista.        |
| `write()`      | Escribe una cadena en el archivo (sobreescribe).       |
| `writelines()` | Escribe una lista de l√≠neas en el archivo.             |
| `close()`      | Cierra el archivo (no es necesario con `with open()`). |

### üìîPersistencia con Archivos de texto

**Ejemplo pr√°ctico** que utiliza el manejo de archivos de texto en Python. Implementaremos un **gestor de tareas**, donde el usuario podr√°:

‚úÖ Agregar tareas
‚úÖ Listar tareas
‚úÖ Marcar tareas como completadas
‚úÖ Eliminar tareas
‚úÖ Guardar todas las tareas en un archivo de texto (`tareas.txt`)**

#### **üìú C√≥digo del Gestor de Tareas**

```python
import os

ARCHIVO_TAREAS = "tareas.txt"

# Funci√≥n para inicializar el archivo de tareas
def inicializar_archivo():
    if not os.path.exists(ARCHIVO_TAREAS):
        with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
            archivo.write("")

# Funci√≥n para agregar una tarea
def agregar_tarea(tarea):
    with open(ARCHIVO_TAREAS, "a", encoding="utf-8") as archivo:
        archivo.write(f"{tarea} | Pendiente\n")
    print(f"‚úÖ Tarea agregada: {tarea}")

# Funci√≥n para listar todas las tareas
def listar_tareas():
    with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
        tareas = archivo.readlines()
    
    if not tareas:
        print("üìÇ No hay tareas registradas.")
    else:
        print("\nüìã Lista de Tareas:")
        for i, tarea in enumerate(tareas, start=1):
            print(f"{i}. {tarea.strip()}")

# Funci√≥n para marcar una tarea como completada
def completar_tarea(numero):
    with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
        tareas = archivo.readlines()

    if 1 <= numero <= len(tareas):
        tareas[numero - 1] = tareas[numero - 1].replace("Pendiente", "Completada")
        with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
            archivo.writelines(tareas)
        print(f"‚úÖ Tarea {numero} marcada como completada.")
    else:
        print("‚ùå N√∫mero de tarea inv√°lido.")

# Funci√≥n para eliminar una tarea
def eliminar_tarea(numero):
    with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
        tareas = archivo.readlines()

    if 1 <= numero <= len(tareas):
        tarea_eliminada = tareas.pop(numero - 1)
        with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
            archivo.writelines(tareas)
        print(f"üóëÔ∏è Tarea eliminada: {tarea_eliminada.strip()}")
    else:
        print("‚ùå N√∫mero de tarea inv√°lido.")

# Funci√≥n principal con men√∫ interactivo
def menu():
    inicializar_archivo()
    while True:
        print("\nüìå Men√∫ de Gestor de Tareas")
        print("1Ô∏è‚É£ Agregar tarea")
        print("2Ô∏è‚É£ Listar tareas")
        print("3Ô∏è‚É£ Marcar tarea como completada")
        print("4Ô∏è‚É£ Eliminar tarea")
        print("5Ô∏è‚É£ Salir")
        opcion = input("Selecciona una opci√≥n: ")

        if opcion == "1":
            tarea = input("Descripci√≥n de la tarea: ")
            agregar_tarea(tarea)
        elif opcion == "2":
            listar_tareas()
        elif opcion == "3":
            listar_tareas()
            num = int(input("N√∫mero de la tarea a completar: "))
            completar_tarea(num)
        elif opcion == "4":
            listar_tareas()
            num = int(input("N√∫mero de la tarea a eliminar: "))
            eliminar_tarea(num)
        elif opcion == "5":
            print("üëã Saliendo del gestor de tareas...")
            break
        else:
            print("‚ùå Opci√≥n inv√°lida. Int√©ntalo de nuevo.")

# Ejecutar el men√∫
if __name__ == "__main__":
    menu()

```

#### **üîç Explicaci√≥n del C√≥digo**

1. **`inicializar_archivo()`**
   - Crea el archivo `tareas.txt` si no existe.
2. **`agregar_tarea(tarea)`**
   - A√±ade una nueva tarea al archivo, marc√°ndola como `Pendiente`.
3. **`listar_tareas()`**
   - Muestra todas las tareas guardadas en el archivo.
4. **`completar_tarea(numero)`**
   - Cambia el estado de una tarea de `Pendiente` a `Completada`.
5. **`eliminar_tarea(numero)`**
   - Borra una tarea espec√≠fica del archivo.
6. **`menu()`**
   - Muestra un men√∫ interactivo para gestionar las tareas.

### üìîPersistencia de datos CSV

#### **üìå Ejercicio: Gesti√≥n de Contactos**

Crea un programa en Python que permita:

1. **Agregar contactos** con nombre, tel√©fono y correo electr√≥nico.
2. **Listar los contactos** guardados en el archivo `contactos.csv`.
3. **Buscar un contacto** por nombre.
4. **Eliminar un contacto** por nombre.

------

##### **üìú C√≥digo Base**

```python
import csv
import os

# Nombre del archivo CSV
ARCHIVO_CSV = "contactos.csv"

# Funci√≥n para verificar si el archivo CSV existe, si no, lo crea con encabezados
def inicializar_archivo():
    if not os.path.exists(ARCHIVO_CSV):
        with open(ARCHIVO_CSV, mode="w", newline="", encoding="utf-8") as archivo:
            escritor = csv.writer(archivo)
            escritor.writerow(["Nombre", "Tel√©fono", "Email"])

# Funci√≥n para agregar un contacto
def agregar_contacto(nombre, telefono, email):
    with open(ARCHIVO_CSV, mode="a", newline="", encoding="utf-8") as archivo:
        escritor = csv.writer(archivo)
        escritor.writerow([nombre, telefono, email])
    print(f"‚úÖ Contacto {nombre} agregado correctamente.")

# Funci√≥n para listar contactos
def listar_contactos():
    with open(ARCHIVO_CSV, mode="r", encoding="utf-8") as archivo:
        lector = csv.reader(archivo)
        contactos = list(lector)

    if len(contactos) <= 1:
        print("üìÇ No hay contactos almacenados.")
    else:
        print("\nüìú Lista de contactos:")
        for i, contacto in enumerate(contactos[1:], start=1):  # Saltar encabezado
            print(f"{i}. {contacto[0]} - {contacto[1]} - {contacto[2]}")

# Funci√≥n para buscar un contacto por nombre
def buscar_contacto(nombre):
    with open(ARCHIVO_CSV, mode="r", encoding="utf-8") as archivo:
        lector = csv.reader(archivo)
        next(lector)  # Saltar encabezado
        for contacto in lector:
            if contacto[0].lower() == nombre.lower():
                print(f"üîç Contacto encontrado: {contacto[0]} - {contacto[1]} - {contacto[2]}")
                return
    print(f"‚ùå Contacto '{nombre}' no encontrado.")

# Funci√≥n para eliminar un contacto por nombre
def eliminar_contacto(nombre):
    contactos_actualizados = []
    contacto_eliminado = False

    with open(ARCHIVO_CSV, mode="r", encoding="utf-8") as archivo:
        lector = csv.reader(archivo)
        contactos_actualizados.append(next(lector))  # Guardar encabezado

        for contacto in lector:
            if contacto[0].lower() == nombre.lower():
                contacto_eliminado = True
            else:
                contactos_actualizados.append(contacto)

    if contacto_eliminado:
        with open(ARCHIVO_CSV, mode="w", newline="", encoding="utf-8") as archivo:
            escritor = csv.writer(archivo)
            escritor.writerows(contactos_actualizados)
        print(f"üóëÔ∏è Contacto '{nombre}' eliminado correctamente.")
    else:
        print(f"‚ùå Contacto '{nombre}' no encontrado.")

# Funci√≥n principal para el men√∫ interactivo
def menu():
    inicializar_archivo()
    while True:
        print("\nüìû Men√∫ de Contactos")
        print("1Ô∏è‚É£ Agregar contacto")
        print("2Ô∏è‚É£ Listar contactos")
        print("3Ô∏è‚É£ Buscar contacto")
        print("4Ô∏è‚É£ Eliminar contacto")
        print("5Ô∏è‚É£ Salir")
        opcion = input("Selecciona una opci√≥n: ")

        if opcion == "1":
            nombre = input("Nombre: ")
            telefono = input("Tel√©fono: ")
            email = input("Email: ")
            agregar_contacto(nombre, telefono, email)
        elif opcion == "2":
            listar_contactos()
        elif opcion == "3":
            nombre = input("Ingresa el nombre a buscar: ")
            buscar_contacto(nombre)
        elif opcion == "4":
            nombre = input("Ingresa el nombre del contacto a eliminar: ")
            eliminar_contacto(nombre)
        elif opcion == "5":
            print("üëã Saliendo del programa...")
            break
        else:
            print("‚ùå Opci√≥n inv√°lida. Int√©ntalo de nuevo.")

# Ejecutar el men√∫
if __name__ == "__main__":
    menu()
```

------

##### **üí° Explicaci√≥n del C√≥digo**

1. üìÇ **Crea un archivo CSV si no existe**, con encabezados (`Nombre`, `Tel√©fono`, `Email`).
2. ‚ûï **Agrega contactos** escribi√©ndolos en el archivo CSV.
3. üìÑ **Lista los contactos** ley√©ndolos del archivo CSV.
4. üîé **Busca un contacto** comparando el nombre ingresado con los datos guardados.
5. ‚ùå **Elimina un contacto** reescribiendo el archivo sin el contacto seleccionado.
6. üñ•Ô∏è **Men√∫ interactivo** que permite elegir entre las diferentes opciones.

### üìîPersistencia de datos JSON

Modulo corefiles.py

```python
import os
import json
from typing import Dict, List, Optional

def read_json(file_path: str) -> Dict:
    """Lee y retorna el contenido del archivo JSON"""
    try:
        with open(file_path, "r", encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        return {}

def write_json(file_path: str, data: Dict) -> None:
    """Escribe datos en el archivo JSON"""
    with open(file_path, "w", encoding='utf-8') as file:
        json.dump(data, file, indent=4)

def update_json(file_path: str, data: Dict, path: Optional[List[str]] = None) -> None:
    """
    Actualiza datos en el JSON, opcionalmente en una ruta espec√≠fica
    Ejemplo: update_json('db.json', {'nuevo': 'dato'}, ['ruta', 'subruta'])
    """
    current_data = read_json(file_path)
    
    if not path:
        current_data.update(data)
    else:
        current = current_data
        for key in path[:-1]:
            current = current.setdefault(key, {})
        if path:
            current.setdefault(path[-1], {}).update(data)

    write_json(file_path, current_data)

def delete_json(file_path: str, path: List[str]) -> bool:
    """
    Elimina datos en la ruta especificada
    Retorna True si se elimin√≥ exitosamente
    """
    data = read_json(file_path)
    current = data

    for key in path[:-1]:
        if key not in current:
            return False
        current = current[key]

    if path and path[-1] in current:
        del current[path[-1]]
        write_json(file_path, data)
        return True
    return False

def initialize_json(file_path: str, initial_structure: Dict) -> None:
    """
    Inicializa el archivo con una estructura base si no existe
    """
    if not os.path.isfile(file_path):
        write_json(file_path, initial_structure)
    else:
        current_data = read_json(file_path)
        for key, value in initial_structure.items():
            if key not in current_data:
                current_data[key] = value
        write_json(file_path, current_data)
```

main.py

```python
import corefiles as cf
import json

# Inicializaci√≥n
DB_FILE = "database.json"

def menu_principal():
    while True:
        print("\nüéØ SISTEMA DE GESTI√ìN ACAD√âMICA")
        print("1. Gestionar Campers")
        print("2. Gestionar Rutas")
        print("3. Ver datos")
        print("4. Salir")
        
        opcion = input("\nSeleccione una opci√≥n: ")
        
        if opcion == "1":
            menu_campers()
        elif opcion == "2":
            menu_rutas()
        elif opcion == "3":
            mostrar_datos()
        elif opcion == "4":
            print("¬°Hasta luego! üëã")
            break
        else:
            print("‚ùå Opci√≥n inv√°lida")

def menu_campers():
    while True:
        print("\nüë• GESTI√ìN DE CAMPERS")
        print("1. Agregar camper")
        print("2. Editar camper")
        print("3. Eliminar camper")
        print("4. Volver al men√∫ principal")
        
        opcion = input("\nSeleccione una opci√≥n: ")
        
        if opcion == "1":
            id_camper = input("ID del camper: ")
            nombre = input("Nombre: ")
            edad = input("Edad: ")
            
            nuevo_camper = {
                id_camper: {
                    "nombre": nombre,
                    "edad": edad
                }
            }
            
            cf.update_json(DB_FILE, nuevo_camper, ["campers"])
            print("‚úÖ Camper agregado exitosamente")
            
        elif opcion == "2":
            id_camper = input("ID del camper a editar: ")
            datos = cf.read_json(DB_FILE)
            
            if id_camper in datos.get("campers", {}):
                print("\nDatos actuales:")
                print(f"Nombre: {datos['campers'][id_camper]['nombre']}")
                print(f"Edad: {datos['campers'][id_camper]['edad']}")
                
                nombre = input("\nNuevo nombre (Enter para mantener actual): ")
                edad = input("Nueva edad (Enter para mantener actual): ")
                
                camper_actualizado = {}
                if nombre:
                    camper_actualizado["nombre"] = nombre
                else:
                    camper_actualizado["nombre"] = datos['campers'][id_camper]['nombre']
                    
                if edad:
                    camper_actualizado["edad"] = edad
                else:
                    camper_actualizado["edad"] = datos['campers'][id_camper]['edad']
                
                cf.update_json(DB_FILE, camper_actualizado, ["campers", id_camper])
                print("‚úÖ Camper actualizado exitosamente")
            else:
                print("‚ùå Camper no encontrado")
            
        elif opcion == "3":
            id_camper = input("ID del camper a eliminar: ")
            cf.delete_json(DB_FILE, ["campers", id_camper])
            print("üóëÔ∏è Camper eliminado exitosamente")
            
        elif opcion == "4":
            break
        else:
            print("‚ùå Opci√≥n inv√°lida")

def menu_rutas():
    while True:
        print("\nüìö GESTI√ìN DE RUTAS")
        print("1. Crear nueva ruta")
        print("2. Editar ruta")
        print("3. Agregar nivel a ruta")
        print("4. Eliminar ruta")
        print("5. Volver al men√∫ principal")
        
        opcion = input("\nSeleccione una opci√≥n: ")
        
        if opcion == "1":
            nombre_ruta = input("Nombre de la ruta: ")
            nueva_ruta = {
                nombre_ruta: {
                    "nivel1": {},
                    "nivel2": {},
                    "nivel3": {}
                }
            }
            cf.update_json(DB_FILE, nueva_ruta, ["rutas"])
            print("‚úÖ Ruta creada exitosamente")
            
        elif opcion == "2":
            nombre_ruta = input("Nombre de la ruta a editar: ")
            datos = cf.read_json(DB_FILE)
            
            if nombre_ruta in datos.get("rutas", {}):
                nivel = input("Nivel a editar (nivel1/nivel2/nivel3): ")
                
                if nivel in datos["rutas"][nombre_ruta]:
                    print("\nDatos actuales:")
                    nivel_actual = datos["rutas"][nombre_ruta][nivel]
                    if "trainer" in nivel_actual:
                        print(f"Trainer actual: {nivel_actual['trainer']}")
                    
                    nuevo_trainer = input("\nNuevo trainer (Enter para mantener actual): ")
                    
                    if nuevo_trainer:
                        info_nivel = {
                            "trainer": nuevo_trainer,
                            "estudiantes": nivel_actual.get("estudiantes", {})
                        }
                        cf.update_json(DB_FILE, info_nivel, ["rutas", nombre_ruta, nivel])
                        print("‚úÖ Ruta actualizada exitosamente")
                else:
                    print("‚ùå Nivel no encontrado")
            else:
                print("‚ùå Ruta no encontrada")
            
        elif opcion == "3":
            ruta = input("Nombre de la ruta: ")
            nivel = input("Nivel (nivel1/nivel2/nivel3): ")
            trainer = input("Nombre del trainer: ")
            
            info_nivel = {
                "trainer": trainer,
                "estudiantes": {}
            }
            
            cf.update_json(DB_FILE, info_nivel, ["rutas", ruta, nivel])
            print("‚úÖ Nivel agregado exitosamente")
            
        elif opcion == "4":
            ruta = input("Nombre de la ruta a eliminar: ")
            cf.delete_json(DB_FILE, ["rutas", ruta])
            print("üóëÔ∏è Ruta eliminada exitosamente")
            
        elif opcion == "5":
            break
        else:
            print("‚ùå Opci√≥n inv√°lida")

def mostrar_datos():
    datos = cf.read_json(DB_FILE)
    print("\nüìä DATOS ACTUALES:")
    print(json.dumps(datos, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    estructura_inicial = {
        "campers": {},
        "rutas": {}
    }
    cf.initialize_json(DB_FILE, estructura_inicial)
    menu_principal()
```

#### **1Ô∏è‚É£ `read_json(file_path: str) -> Dict`**

üîπ **Lee el archivo JSON y retorna su contenido como un diccionario**.
üîπ Si el archivo no existe, devuelve `{}` (un diccionario vac√≠o).

```
def read_json(file_path: str) -> Dict:
    """Lee y retorna el contenido del archivo JSON"""
    try:
        with open(file_path, "r", encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        return {}
```

‚úÖ **Ejemplo de uso**:

```
data = read_json("datos.json")
print(data)
```

Si `datos.json` contiene:

```
{
    "nombre": "Juan",
    "edad": 25
}
```

Salida:

```
{'nombre': 'Juan', 'edad': 25}
```

------

#### **2Ô∏è‚É£ `write_json(file_path: str, data: Dict) -> None`**

üîπ **Escribe un diccionario en un archivo JSON**, sobrescribiendo el contenido.

```
def write_json(file_path: str, data: Dict) -> None:
    """Escribe datos en el archivo JSON"""
    with open(file_path, "w", encoding='utf-8') as file:
        json.dump(data, file, indent=4)
```

‚úÖ **Ejemplo de uso**:

```
write_json("datos.json", {"usuario": "Pedro", "edad": 30})
```

Esto generar√° un archivo `datos.json` con:

```
{
    "usuario": "Pedro",
    "edad": 30
}
```

------

#### **3Ô∏è‚É£ `update_json(file_path: str, data: Dict, path: Optional[List[str]] = None) -> None`**

üîπ **Actualiza datos dentro del JSON**, ya sea globalmente o en una ruta espec√≠fica.
üîπ Si `path` es `None`, actualiza la ra√≠z.
üîπ Si `path` tiene una lista de claves, actualiza solo esa parte.

```
def update_json(file_path: str, data: Dict, path: Optional[List[str]] = None) -> None:
    """
    Actualiza datos en el JSON, opcionalmente en una ruta espec√≠fica
    Ejemplo: update_json('db.json', {'nuevo': 'dato'}, ['ruta', 'subruta'])
    """
    current_data = read_json(file_path)
    
    if not path:
        current_data.update(data)
    else:
        current = current_data
        for key in path[:-1]:
            current = current.setdefault(key, {})
        if path:
            current.setdefault(path[-1], {}).update(data)

    write_json(file_path, current_data)
```

‚úÖ **Ejemplo 1 (Actualizar la ra√≠z del JSON)**:

```
update_json("datos.json", {"telefono": "123456789"})
```

Si `datos.json` ten√≠a:

```
{
    "usuario": "Pedro",
    "edad": 30
}
```

Ahora tendr√°:

```
{
    "usuario": "Pedro",
    "edad": 30,
    "telefono": "123456789"
}
```

‚úÖ **Ejemplo 2 (Actualizar un valor dentro de una estructura anidada)**:

```
update_json("datos.json", {"ciudad": "Bogot√°"}, ["direccion"])
```

Si `datos.json` era:

```
{
    "usuario": "Pedro",
    "direccion": {}
}
```

Despu√©s de la actualizaci√≥n:

```
{
    "usuario": "Pedro",
    "direccion": {
        "ciudad": "Bogot√°"
    }
}
```

------

#### **4Ô∏è‚É£ `delete_json(file_path: str, path: List[str]) -> bool`**

üîπ **Elimina datos dentro del JSON en una ruta espec√≠fica**.
üîπ Retorna `True` si se elimin√≥ correctamente, `False` si la clave no existe.

```
def delete_json(file_path: str, path: List[str]) -> bool:
    """
    Elimina datos en la ruta especificada
    Retorna True si se elimin√≥ exitosamente
    """
    data = read_json(file_path)
    current = data

    for key in path[:-1]:
        if key not in current:
            return False
        current = current[key]

    if path and path[-1] in current:
        del current[path[-1]]
        write_json(file_path, data)
        return True
    return False
```

‚úÖ **Ejemplo de uso**:

```
delete_json("datos.json", ["direccion", "ciudad"])
```

Si `datos.json` ten√≠a:

```
{
    "usuario": "Pedro",
    "direccion": {
        "ciudad": "Bogot√°",
        "codigo_postal": "110111"
    }
}
```

Despu√©s de la eliminaci√≥n:

```
{
    "usuario": "Pedro",
    "direccion": {
        "codigo_postal": "110111"
    }
}
```

Si la clave no existe, la funci√≥n devuelve `False`.

------

#### **5Ô∏è‚É£ `initialize_json(file_path: str, initial_structure: Dict) -> None`**

üîπ **Crea un archivo JSON con una estructura inicial si no existe**.
üîπ Si ya existe, verifica si faltan claves y las agrega sin modificar los datos existentes.

```
def initialize_json(file_path: str, initial_structure: Dict) -> None:
    """
    Inicializa el archivo con una estructura base si no existe
    """
    if not os.path.isfile(file_path):
        write_json(file_path, initial_structure)
    else:
        current_data = read_json(file_path)
        for key, value in initial_structure.items():
            if key not in current_data:
                current_data[key] = value
        write_json(file_path, current_data)
```

‚úÖ **Ejemplo de uso**:

```
initialize_json("datos.json", {"usuarios": {}, "config": {"modo": "oscuro"}})
```

Si `datos.json` no existe, se crea con:

```
{
    "usuarios": {},
    "config": {
        "modo": "oscuro"
    }
}
```

Si `datos.json` ya exist√≠a con:

```
{
    "usuarios": {
        "Juan": {"edad": 25}
    }
}
```

Despu√©s de `initialize_json()`, se actualizar√° a:

```
{
    "usuarios": {
        "Juan": {"edad": 25}
    },
    "config": {
        "modo": "oscuro"
    }
}
```

üîπ La clave `"usuarios"` no se modifica porque ya exist√≠a.
üîπ Se agrega `"config"` porque no estaba presente.

------

#### **üìå Resumen del C√≥digo**

| **Funci√≥n**                                     | **Descripci√≥n**                                          |
| ----------------------------------------------- | -------------------------------------------------------- |
| `read_json(file_path)`                          | Lee un JSON y lo retorna como diccionario.               |
| `write_json(file_path, data)`                   | Escribe datos en un JSON, sobrescribi√©ndolo.             |
| `update_json(file_path, data, path)`            | Actualiza datos en una ruta espec√≠fica del JSON.         |
| `delete_json(file_path, path)`                  | Elimina datos en una ruta espec√≠fica del JSON.           |
| `initialize_json(file_path, initial_structure)` | Inicializa un JSON con una estructura base si no existe. |
